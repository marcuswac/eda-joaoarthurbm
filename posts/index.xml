
   <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
     <channel>
       <title>Posts on Estrutura de Dados</title>
       <link>https://joaoarthurbm.github.io/eda/posts/</link>
       <description>Recent content in Posts on Estrutura de Dados</description>
       <generator>Hugo -- gohugo.io</generator>
       <copyright>Copyright &amp;copy; 2019 - João Arthur Brunet</copyright>
       <lastBuildDate>Wed, 30 Oct 2019 00:00:00 -0300</lastBuildDate>
       
           <atom:link href="https://joaoarthurbm.github.io/eda/posts/index.xml" rel="self" type="application/rss+xml" />
       
       
       <item>
         <title>Introdução à Análise de Algoritmos</title>
         <link>https://joaoarthurbm.github.io/eda/posts/introducao-a-analise/</link>
         <pubDate>Wed, 30 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/introducao-a-analise/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;A análise de eficiência é uma etapa fundamental na concepção de um algoritmo. Embora aspectos como legibilidade, simplicidade e modularidade de uma solução sejam importantes para a sua manutenabilidade, a eficiência de uma solução desempenha um papel muito relevante para a sua adoção.&lt;/p&gt;

&lt;p&gt;Diante de um problema computacional, diversas soluções podem ser propostas. Por exemplo, para ordenar um sequência de números, o desenvolvedor pode utilizar algoritmos como o BubbleSort, MergeSort, QuickSort entre outros. Entender como esses algoritmos se comportam à medida que aumentamos o tamanho da entrada a ser ordenada é primordial para decidirmos qual solução adotar em um determinado contexto.&lt;/p&gt;

&lt;p&gt;Analisar um algoritmo significa prever a quantidade de recursos que tal algoritmo consome ao ser executado. A análise pode apontar diversos candidatos e, tipicamente, exclui diversas soluções não eficientes. Diversas variáveis podem ser objetos de estudo da análise de um algoritmo, por exemplo, consumo de memória, largura de banda de comunicação entre outros. No entanto, com frequência, desejamos medir o tempo execução. E é essa variável que estamos interessados em discutir neste documento.&lt;/p&gt;

&lt;p&gt;Uma abordagem direta para analisar o desempenho de um algoritmo é a abordagem empírica. Neste caso, configura-se um ambiente em que as variáveis são controladas e executa-se os algoritmos com o intuito de medir o tempo de computação e comparar as diferentes soluções.
O tempo de execução (eixo y) é medido em função do tamanho da entrada (eixo x). Por exemplo, para analisar empiricamente um algoritmo de ordenação medimos o tempo de execução para diferentes tamanhos de arrays. Além disso, podemos querer variar a configuração do array sob ordenação para entender, por exemplo, como o algoritmo se comporta com um array já ordenado ou como se comporta com arrays parcialmente ordenados.&lt;/p&gt;

&lt;p&gt;Tipicamente, executa-se um experimento com o tamanho da amostra suficiente para se ter validade estatística e permitir a construção de um modelo que represente a curva de cada algoritmo. A Figura abaixo apresenta os tempos de computação de diferentes algoritmos de ordenação à medida que aumenta-se o tamanho da entrada. Como podemos notar, o algoritmo SelectionSort apresenta tempo de execução consideravelmente maior em comparação com as outras três alternativas à medida que a quantidade de elementos a serem ordenados cresce.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;comparacao-ordenacao.jpeg&#34; alt=&#34;comp-ordenacao&#34; title=&#34;Comparação de Algoritmos de Ordenação&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A abordagem empírica para análise de algoritmos é útil, pois, se conduzida de maneira metodologicamente apropriada, fornece valores precisos sobre o tempo de execução de um algoritmo. No entanto, essa abordagem apresenta algumas desvantagens. Primeiro, existe um alto custo relacionado à implementação de todos os algoritmos, além da configuração, execução e análise do experimento. Além disso, note que as conclusões são limitadas ao espaço de entrada do experimento. Por fim, os resultados são dependentes do hardware utilizado.&lt;/p&gt;

&lt;p&gt;Diante do cenário exposto acima, surge a necessidade de uma análise que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;seja independente de hardware;&lt;/li&gt;
&lt;li&gt;permita analisar os algoritmos em um espectro maior de entradas;&lt;/li&gt;
&lt;li&gt;seja simples.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note que, em diversas situações, o interesse está em comparar algoritmos, ao invés de determinar o seu tempo exato de execução. Em particular, &lt;strong&gt;estamos interessados nas funções no comportamento dos algoritmos para grandes tamanhos de entrada &amp;ndash; análise assintótica.&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;análise-de-algoritmos&#34;&gt;Análise de Algoritmos&lt;/h2&gt;

&lt;p&gt;Antes de apresentar os conceitos de análise assintótica, sua notação e modus operandi, é preciso apresentar a hipótese em que a análise de algoritmos se baseia:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;Hipótese: O custo de operações primitivas é constante.&lt;/p&gt;

&lt;p&gt;Essa hipótese estabelece que operações aritméticas, indexação de elementos em um vetor, retorno de métodos, atribuição de valores às variáveis, comparação de elementos, entre outros, executam em tempo constante, referenciado como $O(1)$ ou $O(C)$. É importante destacar que, na prática, esse custo varia de acordo com o hardware, linguagem de programação etc. No entanto, essa variação é insignificante do ponto de vista da análise assintótica. O quadro abaixo lista as operações primitivas detalhadamente.&lt;/p&gt;

&lt;pre&gt;
Operações Primitivas

* Avaliação de expressões booleanas (i &gt;= 2; i == 2, etc);

* Operações matemáticas (*, -, +, %, etc);

* Retorno de métodos (return x;);

* Atribuição (i = 2);

* Acesso à variáveis e posições arbitrárias de um array (v[i]).

&lt;/pre&gt;

&lt;p&gt;Nesse contexto, o tempo de execução de um algoritmo é a soma do custo das operações primitivas. Por exemplo, considere o algoritmo que multiplica o resto da divisão de dois inteiros pela parte inteira da mesma divisão:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;multiplicaRestoPorParteInteira&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resto&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; j;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pInteira&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; j;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;resultado&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; resto &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pInteira;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; resultado;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1: Identificar primitivas.&lt;/strong&gt; O primeiro passo para determinar de modo analítico o tempo de execução de qualquer algoritmo é identificar todas as operações primitivas. Cada uma, como discutido anteriormente, tem um custo constante. Para o algoritmo acima temos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;atribuição (resto = ) -&amp;gt; $c1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (i % j) -&amp;gt; $c2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (pInteira = ) -&amp;gt; $c3$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (i % j) -&amp;gt; $c4$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (resultado = ) -&amp;gt; $c5$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (resto * pInteira) -&amp;gt; $c6$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;retorno de método (return resultado) -&amp;gt; $c7$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt; Para o algoritmo acima, todas as primitivas são executadas apenas uma vez.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt; O tempo de execução do algoritmo é a soma das execuções das operações primitivas. Nesse caso temos que a função que descreve o tempo de execução é:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = c1+c2+c3+c4+c5+c6+c7$&lt;/p&gt;

&lt;p&gt;Lembrando estamos interessados em uma função que nos diga o tempo de execução em relação ao tamanho da entrada. Nesse caso, escolhemos $n$ para representar o tamanho da entrada. Como pode ser visto na função detalhada, o custo não depende de $n$ de maneira alguma. Independente dos números passados como parâmetro, o custo será sempre o mesmo. Por isso dizemos que essa função, e portanto o algoritmo que é descrito por ela, tem &lt;strong&gt;custo constante&lt;/strong&gt;, ou seja, independe do tamanho da entrada.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dizer que um algoritmo tem custo constante significa dizer que o seu tempo de execução independe do tamanho da entrada.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Outro fator de destaque é que podemos considerar que todas as constantes possuem o mesmo valor $c$. Assim, podemos simplificar a função para $f(n)= 7c$.&lt;/p&gt;

&lt;h3 id=&#34;e-quando-houver-condicionais&#34;&gt;E quando houver condicionais?&lt;/h3&gt;

&lt;p&gt;O uso de comandos condicionais é muito comum em nossos algoritmos e nos impõe uma dificuldade na análise do tempo de execução. Essa dificuldade está relacionada ao fato de que, dependendo do caso, apenas uma parte do código é executada. Como decidir como fazer a análise? Que caminho devemos computar?&lt;/p&gt;

&lt;p&gt;Nesse caso, escolhemos &lt;strong&gt;o pior caso&lt;/strong&gt;. Neste curso estamos interessados em saber como os algoritmos se comportam no seu pior caso. A análise do pior caso é útil para eliminarmos soluções ruins. Além disso, o melhor caso raramente acontece, ao contrário dos outros casos que podem ser bem mais comuns. Por último, o caso médio, além de demandar análise estatística, muitas vezes é muito semelhante ao pior caso.&lt;/p&gt;

&lt;p&gt;Para demonstrar a análise de pior caso, vamos analisar um método que recebe as três notas de um aluno e calcula a nota que ele precisa obter na prova final, se esse for o caso. Se o aluno for aprovado ($media &amp;gt;= 7.0$) ou reprovado sem direito a final ($media &amp;lt; 4$), o método deve retornar $0$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;precisaNaFinal&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nota1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nota2&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;nota3&lt;/span&gt;) {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;media&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (nota1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nota2 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; nota3) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 3;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (media &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 7 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; media &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 4) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 0;
        
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mediaFinal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 5;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pesoFinal&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0.&lt;span style=&#34;color:#a6e22e&#34;&gt;4&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pesoMedia&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0.&lt;span style=&#34;color:#a6e22e&#34;&gt;6&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;precisa&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (mediaFinal &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; pesoMedia &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; media) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; pesoFinal;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; precisa;
    }

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1. Identificar primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;atribuição (media = ) -&amp;gt; $c1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (nota1 + nota2 + nota3) -&amp;gt; $c2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (&amp;hellip; / 3) -&amp;gt; $c3$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;avaliação de expressão booleana (media &amp;gt;=7 || media &amp;lt; 4) -&amp;gt; $c4$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;retorno de método (return 0) -&amp;gt; $c5$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (mediaFinal = ) -&amp;gt; $c6$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (pesoFinal = ) -&amp;gt; $c7$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (pesoMedia = ) -&amp;gt; $c8$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atribuição (precisa = ) -&amp;gt; $c9$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (pesoMedia * media) -&amp;gt; $c10$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (mediaFinal -  &amp;hellip;) -&amp;gt; $c11$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;operação aritmética (&amp;hellip; / pesoFinal) -&amp;gt; $c12$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;retorno de método (return precisa) -&amp;gt; $c13$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt; Aqui vem a grande diferença. Como estamos interessados no pior caso, nós vamos descartar a constante $c5$, pois, no pior caso, o bloco do &lt;code&gt;else&lt;/code&gt; será executado, uma vez que é mais custoso que o bloco do &lt;code&gt;if&lt;/code&gt;. As outras primitivas são executadas apenas uma vez.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = c1+c2+c3+c4+c6+c7+c8+c9+c10+c11+c12+c13$ &lt;/p&gt;

&lt;h3 id=&#34;e-quando-houver-iteração&#34;&gt;E quando houver iteração?&lt;/h3&gt;

&lt;p&gt;Nos dois exemplos que vimos até aqui todas as primitivas são executadas apenas uma vez e, por isso, o tempo de execução do algoritmo é sempre constante. Vejamos o que acontece quando há iteração. O código abaixo procura por um elemento em um array.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;contains&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (v[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1: Identificar primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Atribuição (int i = 0) -&amp;gt; $c1$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (i &amp;lt; v.length) -&amp;gt; $c2$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operação aritmética (i++) -&amp;gt; $c3$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (v[i] == n) -&amp;gt; $c4$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return true) -&amp;gt; $c5$&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return false) -&amp;gt; $c6$&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Aqui mora a grande diferença da análise deste exemplo em relação aos demais. Em primeiro lugar, nem todas as primitivas são executadas apenas uma vez. Depois, temos que voltar a lembrar que estamos tratando do pior caso. Esse cenário é representado por um array que não contém o número procurado, pois o algoritmo irá realizar todas as iterações e retornar &lt;code&gt;false&lt;/code&gt; no final. Veja que se o número procurado estiver presente, a execução pode terminar bem antes do fim da iteração no array. Isso significa que na nossa análise vamos descartar a primitiva $c5$, pois no pior caso ela nunca é executada.&lt;/p&gt;

&lt;p&gt;Dado que o tamanho do vetor (&lt;code&gt;v.length&lt;/code&gt;) é $n$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$c1$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c2$ é executada $(n+1)$ vezes. Exemplo: se $n = 5$, temos as seguintes verificações: 0 &amp;lt; 5, 1 &amp;lt; 5; 2 &amp;lt; 5, 3 &amp;lt; 5, 4 &amp;lt; 5 e 5 &amp;lt; 5, quando encerra-se o loop. Ou seja, 6 verificações.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c3$ é executada $n$ vezes. Exemplo: se $n = 5$, temos os seguintes incrementos em i: 1, 2, 3, 4 e 5, quando encerra-se o loop.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c4$ é executada $n$ vezes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No pior caso, $c5$ não é executada.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c6$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O tempo de execução do algoritmo é a soma das execuções das operações primitivas. Nesse caso temos que a função que descreve o tempo de execução é:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = c1+c2*(n+1)+c3*n+c4*n+c6$ &lt;/p&gt;

&lt;p&gt;Considerando todas as primitivas com custo $c$ e simplificando a função, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = 3*c*n+3*c$ &lt;/p&gt;

&lt;p&gt;Veja que essa função é diretamente relacionada ao tamanho do array ($n$). À medida que cresce o tamanho de $n$, cresce também o tempo de execução do pior caso. Esse crescimento é linear, pois a função é linear. Faz sentido, certo? Iterar em um array com 100 posições é 10 vezes mais lento que iterar em um array de 10 posições. Não é por acaso que o nome desse algoritmo é busca linear. O termo refere-se a ambos: i) a estratégia de procurar o elemento de modo sequencial em uma coleção e ii) o tempo de execução do algoritmo.&lt;/p&gt;

&lt;p&gt;Vamos ver mais um exemplo.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; contemDuplicacao(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; j&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (v[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; v[j])
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Passo 1: Identificar primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Atribuição (int i = 0) -&amp;gt; c1&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (i &amp;lt; v.length) -&amp;gt; c2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operação aritmética (i++) -&amp;gt; c3&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Atribuição (int j = i + 1) -&amp;gt; c4&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (j &amp;lt; v.length) -&amp;gt; c5&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Operação aritmética (j++) -&amp;gt; c6&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Avaliação de expressão booleana (v[i] == v[j]) -&amp;gt; c7&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return true) -&amp;gt; c8&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Retorno de método (return false) -&amp;gt; c9&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Identificar a quantidade de vezes que cada uma das primitivas é executada.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O pior caso de execução desse algoritmo é quando não há repetição de valores no array. Ou seja, os loops são executados até o final. Então, como estamos falando do pior caso, descartamos $c8$, porque no pior caso essa primitiva nunca será executada.&lt;/p&gt;

&lt;p&gt;Dado que o tamanho do vetor (v.length) é $n$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$c1$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c2$ é executada $(n+1)$ vezes. Exemplo: se $n = 5$, temos as seguintes verificações: 0 &amp;lt; 5, 1 &amp;lt; 5; 2 &amp;lt; 5, 3 &amp;lt; 5, 4 &amp;lt; 5 e 5 &amp;lt; 5, quando encerra-se o loop. Ou seja, 6 verificações.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c3$ é executada $n$ vezes. Exemplo: se $n = 5$, temos os seguintes incrementos em i: 1, 2, 3, 4 e 5, quando encerra-se o loop.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Agora, atenção, porque vamos tratar das primitivas do laço mais interno.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A quantidade de vezes que $c4$ é executada depende do laço mais externo, pois $j$ varia de acordo com $i$ ($j = i+1$). Como o laço externo executa $n$ vezes, a quantidade de vezes que $j$ varia é dada por: $(n - 1) + (n - 2) + (n - 3) + (n-4) + &amp;hellip;1$. Essa série representa uma Progressão Aritmética finita decrescente com razão 1. A soma de uma PA com essas características é dada por $S = n/2 * (a1+an)$, onde $a1$ e $an$ são o primeiro e o último elemento da sequência, respectivamente. Assim, para $a1=1$ e $an = n-1$, temos que $c4$ é executada ${n^2}/{2}$ vezes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Como $c5$ é executada uma vez a mais que $c4$ por causa do último teste para sair do laço, então temos que o primeiro termo da PA é $a1 = 1$ e $an = n$. Assim, temos que $c5$ é executada $({n^2 + n})/{2}$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c6$ e $c7$ são executadas a mesma quantidade de vezes que $c4$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c8$ não é executada nenhuma vez porque estamos falando do pior caso&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$c9$ é executada apenas uma vez.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Somar o custo total.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O tempo de execução do algoritmo é a soma das execuções das operações primitivas. Nesse caso temos que a função que descreve o tempo de execução é:&lt;/p&gt;

&lt;p&gt;$f(n) = c1 + c2*(n+1) + c3*n + c4 * {n^2}/2 + c5 * (n^2 + n)/2 + c6 * {n^2}/2 + c7 * {n^2}/2 + c9$&lt;/p&gt;

&lt;p&gt;Considerando todas as primitivas com custo c e simplificando a função, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = 3 * c + 2 * c * n + 3 * {n^2}/2 + c * (n^2 + n)/2$ &lt;/p&gt;

&lt;p&gt;Veja que essa função é diretamente relacionada ao tamanho do array (n). À medida que cresce o tamanho de $n$, cresce também o tempo de execução do pior caso. O tempo de execução do algoritmo cresce de forma quadrática em relação ao tamanho da entrada, pois a função é quadrática. Faz sentido, certo? Comparar cada elemento de um array com todos os outros é da ordem de $n^2$.&lt;/p&gt;

&lt;p&gt;É importante que você entenda que esse algoritmo é bem mais lento do que o anterior, pois uma função quadrática cresce mais rapidamente que uma função linear.&lt;/p&gt;

&lt;p&gt;No material sobre &lt;a class=&#34;external&#34; href=&#34;http://joaoarthurbm.github.io/eda/posts/analise-assintotica&#34;&gt;Análise Assintótica&lt;/a&gt; vamos aprender que essa função complicada pode ser simplificada para $n^2$ quando tratamos de grandes entradas, pois as constantes e os expoentes de menor magnitude não impactam muito nesse cenário.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;resumo&#34;&gt;Resumo&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Calcular o tempo de execução de um algoritmo é muito importante.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uma forma de calcular o tempo de execução é seguir os passos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Identificar primitivas&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Identificar o número de vezes que cada uma das primitivas é executada&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Somar o custo total&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;É preciso estar atento para o fato de que estamos falando de análise do pior caso e, por isso, descartamos os fluxos alternativos de menor custo.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
       </item>
       
       <item>
         <title>Análise Assintótica</title>
         <link>https://joaoarthurbm.github.io/eda/posts/analise-assintotica/</link>
         <pubDate>Tue, 29 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/analise-assintotica/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;No &lt;a class=&#34;external&#34; href=&#34;http://joaoarthurbm.github.io/eda/posts/introducao-a-analise/&#34;&gt; material introdutório de análise de algoritmos &lt;/a&gt; aprendemos a definir a função que descreve o custo de execução de algoritmos. Vimos exemplos simples cujas funções são também simples. Contudo, vamos supor que a função que descreve o tempo de execução de um algoritmo é dada por:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $1.1 * n^2 + (10 + \sin(n + 15) * n^{1.5}) + 9000$ &lt;/p&gt;

&lt;p&gt;Você há de convir que não é simples olhar para essa função e ter uma ideia clara do crescimento dela, certo? Lembra que nossa motivação para estabelecer essa função é simplificar nossa vida. É olhar para a função e ter uma ideia de como ela se comporta à medida que o tamanho da entrada cresce. Então, temos um problema aqui. Essa função não está ajudando nossa vida. Precisamos simplificá-la.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A Solução.&lt;/strong&gt; Simplificar. Na verdade, nós já utilizamos algumas simplificações para facilitar a análise de algoritmos. A principal delas é ignorar o custo real das operações primitivas, utilizando a constante C ou 1. Agora, faremos mais uma abstração simplificadora, chamada &lt;strong&gt;ordem de crescimento&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A ideia é determinar como o algoritmo se comporta para valores muito grandes de entrada. Neste caso, ignoramos as constantes e os valores de menor magnitude por entender que eles não são significativos diante dos valores de maior magnitude.&lt;/p&gt;

&lt;p&gt;Na prática, isso significa dizer que podemos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ignorar as constantes;&lt;/li&gt;
&lt;li&gt;ignorar os expoentes de menor magnitude.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;No exemplo fictício da função acima, podemos então fazer as seguintes simplificações.&lt;/p&gt;

&lt;p&gt;f(n) = &lt;del&gt;1.1&lt;/del&gt; * n ** 2 &lt;del&gt;+ (10 + sin(n+15)*n**1.5) + 9000&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;Ou seja, do ponto de vista da ordem de crescimento, para grandes valores de $n$, as constantes e os expoentes de maior magnitude são insignificantes, nos permitindo simplificar a expressão do tempo de execução para $\Theta(n^2)$. A notação theta será discutida com mais detalhes na próxima seção.&lt;/p&gt;

&lt;p&gt;Agora sim, é muito mais direto olhar para $n^2$ ter uma ideia clara do crescimento do tempo de execução do algoritmo, porque $n^2$ é uma função que já conhecemos bastante.&lt;/p&gt;

&lt;p&gt;O interesse está na ordem de crescimento das funções, que facilita a análise e comparação de diferentes soluções. Por exemplo, na escolha entre uma solução $\Theta(\log n)$ e uma solução $\Theta(n)$, é preferível a primeira, pois à medida que o tamanho da entrada cresce, o tempo de execução cresce mais lentamente que $\Theta(n)$.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Ainda não entendi. Você está querendo dizer que $f(n) = 1.1 * n^2 + (10 + \sin(n + 15) * n^{1.5}) + 9000$ e $g(n) = n^2$ são iguais?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Não. Eu estou dizendo que elas pertencem à mesma classe de funções, as funções quadráticas. Eu estou querendo dizer que essas duas funções possuem a mesma ordem de crescimento para grandes entradas e que se aproximam muito uma da outra para grandes valores de $n$.&lt;/p&gt;

&lt;p&gt;Vou te mostrar. Os gráficos da sequência abaixo ilustra essas duas funções. $f(n)$ está destacada em azul e $g(n)$ em vermelho. A única diferença é que a entrada (eixo x) vai aumentando de um gráfico para outro.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;passo1.png&#34; alt=&#34;passo1&#34; /&gt;
&lt;img src=&#34;passo2.png&#34; alt=&#34;passo2&#34; /&gt;
&lt;img src=&#34;passo3.png&#34; alt=&#34;passo3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que no primeiro gráfico, para entradas de 0 a 200, $f(x)$ tem uma curva semelhante à $g(x)$, mas estão distantes uma da outra. Depois, na segunda figura, a entrada passa a variar de 0 a 300 e já conseguimos notar uma aproximação dessas duas curvas. Por fim,  no último gráfico, com entradas variando de 0 a 400, as duas curvas já estão muito próximas uma da outra.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outro exemplo.&lt;/strong&gt; Através da identificação das operações primitivas e da quantidade de vezes que são executadas no algoritmo de busca linear chegamos à seguinte função:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = 3*c*n + 3*c$&lt;/p&gt;

&lt;p&gt;Aplicando as diretrizes simplificação, temos:&lt;/p&gt;

&lt;p&gt;f(n) = &lt;del&gt;3 * c *&lt;/del&gt; n &lt;del&gt;+ 3 * c&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;Isto é, $f(n) = 3*c*n+3*c$ é $\Theta(n)$. Isso significa dizer que f(n) tem a mesma ordem de crescimento que uma função linear.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dizer que um algoritmo é linear significa que o tempo de execução do algoritmo cresce linearmente em função do tamanho da entrada.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Mais um exemplo.&lt;/strong&gt; Através da identificação das operações primitivas e da quantidade de vezes que são executadas no algoritmo de identificação de elementos duplicados em um array chegamos à seguinte função:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $f(n) = 3 * c + 2 * c * n + 3 * {n^2}/2 + c * (n^2 + n)/2$ &lt;/p&gt;

&lt;p&gt;Aplicando as diretrizes simplificação, temos que $f(n) = \Theta(n^2)$. Isso significa dizer que $f(n)$ tem a mesma ordem de crescimento que uma quadrática.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;análise-assintótica&#34;&gt;Análise Assintótica&lt;/h1&gt;

&lt;p&gt;Quando observamos tamanhos de entrada grande o suficiente para tornar relevante apenas a ordem de crescimento do tempo de execução, estamos estudando a eficiência assintótica.&lt;/p&gt;

&lt;p&gt;Há pouco, aplicando as diretrizes de simplificação, aprendemos que funções complexas podem ser mapeadas para classes de funções sobre as quais conhecemos o crescimento ($n$, $\log n$, $n^2$ etc). Para ilustrar esse mapeamento utilizamos a notação $\Theta$. Chegou a hora de entendermos o que essa notação significa.&lt;/p&gt;

&lt;p&gt;Primeiro, preciso deixar claro que cometi alguns abusos matemáticos para fins didáticos. Vamos relembrar esses abusos e explicá-los um a um.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$2*n + 1 = \Theta(n)$&lt;/p&gt;

&lt;p&gt;Theta ($\Theta$) é um conjunto de funções. Nesse caso, o conjunto das funções lineares. Por isso, é um abuso dizer que $2*n + 1$ &lt;strong&gt;é&lt;/strong&gt; $\Theta(n)$. A maneira formal de dizer é: $2*n + 1$ &lt;strong&gt;pertence&lt;/strong&gt; à $\Theta(n)$.&lt;/p&gt;

&lt;p&gt;Além disso, poderíamos ter escolhido qualquer função linear para dizer que $2 * n + 1$ tem a mesma ordem de crescimento. Nós escolhemos $n$ porque é a mais simples.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-notação-theta&#34;&gt;A notação $\Theta$&lt;/h1&gt;

&lt;p&gt;Agora vamos definir formalmente o que significa essa notação. Para duas funções $f(n)$ e $g(n)$, dizemos que $f(n)$ é $\Theta(g(n))$ se&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=c1*g(n)&lt;= f(n)&lt;= c2*g(n), \forall n&gt;=n0$&lt;/p&gt;

&lt;p&gt;Vamos entender o que essa inequação complicada quer nos dizer. Em um resumo bem simplista ela está dizendo que se a gente &amp;ldquo;imprensar&amp;rdquo; $f(n)$ com $g(n)$ multiplicada por duas constantes diferentes, dizemos que $f(n)$ é $\Theta(g(n))$.&lt;/p&gt;

&lt;p&gt;Vamos ao exemplo. Lembra da função que descreve o tempo de execução da busca linear? Vamos tentar demonstrar que essa função é $\Theta(n)$.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = 3*c*n+3*c$&lt;/p&gt;

&lt;p&gt;O primeiro passo que vamos fazer é trocar as constantes por 1. Isso já foi dito antes. Usar $c$ ou 1 tem o mesmo efeito. Assim, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$f(n) = 3n+3$&lt;/p&gt; 

&lt;p&gt;Agora vamos voltar a inequação. Como &amp;ldquo;desconfiamos&amp;rdquo; que $f(n) = 3n+3$ é $\Theta(n)$, escolhemos $g(n)=n$. Poderíamos escolher qualquer função linear para representar $g(n)$, escolhemos a função linear mais simples para facilitar nossa vida. Assim, a inequação fica:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=c1*n&lt;= 3n+3&lt;= c2*n, \forall n&gt;=n0$&lt;/p&gt;  

&lt;p&gt;Agora precisamos encontrar valores para $c1$ e $c2$ para que essa inequação seja verdadeira. Vamos tentar com c1=1 e c2=6.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=n&lt;= 3n+3&lt;= 6*n, \forall n&gt;=n0$&lt;/p&gt;  

&lt;p&gt;Se verificarmos com $n=1$, vemos que a inequação é verdadeira:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0&lt;=1&lt;= 6&lt;= 6$&lt;/p&gt;  

&lt;p&gt;Não é difícil também notar que $\forall n &amp;gt; 1$ ela sempre será verdadeira. Conseguimos, então, demonstrar que $f(n) \in \Theta(n)$, pois $g(n)=n$ limita inferior e superiomente $f(n)$.&lt;/p&gt;

&lt;p&gt;Na verdade, todas as funções lineares são limitadas inferior e superiormente por $n$. No nosso linguajar, podemos dizer que todas as funções abaixo pertencem à $\Theta(n)$.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$7*n, 827643*n, 5n+21, 54n +1...$&lt;/p&gt;  

&lt;p&gt;Formalmente dizemos que $g(n)=n$ é um limite assintótico restrito para $f(n)$. A figura abaixo descreve essa relação entre uma função quadrática e as funções $3n$ e $n^2$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;theta.png&#34; alt=&#34;theta&#34; width=&#34;1px&#34; height=&#34;320px&#34;/&gt;&lt;/p&gt;

&lt;p&gt;Em português estamos dizendo que existe, para grandes valores de $n$ e a partir de um número inteiro positivo $n0$, $c1$ e $c2$ tais que $c1*g(n)&amp;lt;= f(n)&amp;lt;= c2*g(n)$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Em termos simplistas, $f(n) \in \Theta(g(n))$ significa dizer que o crescimento de f(n) é igual ao de g(n).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Outro exemplo.&lt;/strong&gt; Suponha que a função $7 * n^4 + 5 * n^2 +10$ descreva o custo de execução de um algoritmo. Se aplicarmos as abstrações simplificadoras, desconfiamos que $f(n) \in \Theta(n4)$, certo? Vamos demonstrar formalmente.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$0 &lt;= c1 * n^4 &lt;= 7 * n^4 + 5 * n^2 + 10 &lt;= c2*n4, \forall n &gt;= n0$&lt;/p&gt;  

&lt;p&gt;Se escolhermos $c1=7$, $c2=22$ e $n0=1$, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 0 &lt;=7 &lt;= 22 &lt;= 22 $&lt;/p&gt;

&lt;p&gt;Na verdade, todas as funções quadráticas são limitadas inferior e superiormente por $n^2$. No nosso linguajar, podemos dizer que todas as funções abaixo pertencem à $\Theta(n^2)$.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 43 * n^2 + 7n + 1, 5 * n^2 + 21, 7 * n^2...$ &lt;/p&gt;

&lt;p&gt;Em resumo, para demonstrar formalmente precisamos dos seguintes passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Aplicar as abstrações simplificadores em $f(n)$ para termos uma proposta para $g(n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Encontrar valores de $c1$, $c2$ e $n0$ para os quais a inequação $0&amp;lt;=c1*g(n)&amp;lt;= f(n)&amp;lt;= c2*g(n)$ é verdadeira.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Há mais 4(!) notações para estabelecer a relação entre funções. Neste material vamos ver apenas mais duas porque considero que é suficiente. Independente disso, todas são nada mais do que alterações na inequação que estabelecemos para $\Theta$. Por exemplo, a próxima notação que veremos, provavelmente a mais popular de todas, nada mais é do que retirar o limite inferior da inequação e apenas estabelecer um limite superior.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notação-o-big-o-notation&#34;&gt;Notação O (Big O notation)&lt;/h1&gt;

&lt;p&gt;Enquanto a notação $\Theta$ define os limites inferior e superior de uma função, a notação $O$ define apenas o limite superior. Ou seja, define um teto para uma determinada função.&lt;/p&gt;

&lt;p&gt;Para duas funções $f(n)$ e $g(n)$, dizemos que $f(n)$ é $O(g(n))$ se:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0&lt;=f(n)&lt;= c*g(n), \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Veja que a diferença entre essa inequação e a utilizada para a notação é o fato de que aqui o limite inferior é 0 e não $c1 * g(n)$. A figura abaixo ilustra essa relação.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bigo.png&#34; alt=&#34;bigo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O processo para demonstrar que $f(n)$ é $O(g(n))$ é muito semelhante, mas nesse caso precisamos achar apenas os valores de $c$ e $n0$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exemplo.&lt;/strong&gt; Suponha que a função $n^2 + 1$ descreva o custo de execução de um algoritmo. Se aplicarmos as abstrações simplificadoras, desconfiamos que $f(n) \in O(n^2)$, certo? Vamos demonstrar formalmente.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0 &lt;= n^2 + 1 &lt;= c * n^2, \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Se escolhermos c1=1 e n0=1, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $1 &lt;= 1$ &lt;/p&gt;

&lt;p&gt;Como você pode perceber, toda função que pertence à $\Theta(n^2)$ também pertence à $O(n^2)$, porque $\Theta$ limita também superiormente como $O$. No entanto, nem toda função que pertence à $O(n^2)$, por exemplo, também pertence à $\Theta(n)$, pois $O$ estabelece apenas o limite superior. Por exemplo, a função $f(n) = 7$ é limitada superiormente por $n^2$ e, portanto, é $O(n^2)$. Todavia, não podemos dizer que ela é $\Theta(n^2)$ porque não há constante multiplicadora que, para n suficientemente grande, faça com que $c1 * n^2$ seja menor do que $7n$.&lt;/p&gt;

&lt;p&gt;Simples, não é? A notação $O$ é bastante utilizada em Computação para discutir a eficiência de algoritmos. E há aqui uma curiosidade. Como discutido no parágrafo anterior, basta escolhermos uma função com $n$ elevado a um expoente maior do que o da função sob análise que conseguimos definir um limite superior para ele. Por exemplo, a função $f(n) = n^2$ é $O(n^2)$, $O(n^3)$, $O(n^4)$, e assim por diante.  Todavia, faz mais sentido escolhermos uma função com o mesmo expoente, porque a informação é mais precisa. Ou seja, se uma função é quadrática, dizemos que ela é $O(n^2)$.&lt;/p&gt;

&lt;p&gt;Por fim, outra particularidade dessa notação é que usamos com muita frequência nas discussões do a dia a notação $O$ ao invés da notação $\Theta$. Talvez porque seja mais fácil de falar $O$ do que theta e, como somos preguiçosos, tendemos a economizar energia até na fala. Mas é relevante destacar que, tipicamente, a semântica que queremos empregar nas discussões com o uso da notação $O$ é a mesma de $\Theta$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Em termos simplistas, $f(n) \in O(g(n))$ significa dizer que o crescimento de f(n) é menor ou igual ao crescimento de g(n).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notação-omega-omega&#34;&gt;Notação Omega ($\Omega$)&lt;/h1&gt;

&lt;p&gt;A notação $\Theta$ define o limite inferior e superior. $O$ define apenas o limite superior. E $\Omega$? Acertou. Apenas o limite inferior. Para duas funções $f(n)$ e $g(n)$, dizemos que $f(n)$ é $\Omega(g(n))$ se:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 0 &lt;= c * g(n) &lt;= f(n), \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;A figura abaixo ilustra essa relação.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;omega.png&#34; alt=&#34;omega&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O processo para demonstrar que $f(n)$ é $\Omega(g(n))$ é muito semelhante, mas nesse caso precisamos achar apenas os valores de $c$ e $n0$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exemplo.&lt;/strong&gt; Suponha que a função $n^2 + 1$ descreva o custo de execução de um algoritmo. Se aplicarmos as abstrações simplificadoras, desconfiamos que $f(n) \in \Omega(n^2)$, certo? Vamos demonstrar formalmente.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 0 &lt;= c * n^2 &lt;= n^2 + 1, \forall n &gt;= n0$ &lt;/p&gt;

&lt;p&gt;Se escolhermos $c1=1$ e $n0=1$, temos:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $ 1 &lt;= 2$ &lt;/p&gt;

&lt;p&gt;Não é difícil perceber que essa inequação é verdadeira para todo $n0$ maior do que 1.&lt;/p&gt;

&lt;p&gt;Como você pode perceber, toda função que pertence à $\Theta(n^2)$ também pertence à
$\Omega(n^2)$, porque $\Theta$ limita também inferiormente como $\Omega$. Contudo, nem toda função que pertence à $\Omega(n^2)$ também pertence à $\Theta(n^2)$, pois $\Omega(n^2)$ estabelece apenas o limite inferior. Por exemplo, a função $f(n) = 7 * n$ é limitada inferiormente por $n$, portanto é $\Omega(n)$. Contudo, não podemos dizer que ela é $\Theta(n^2)$ porque não há constante multiplicadora que para $n$ suficientemente grande faça com que $c1 * n$ seja maior do que $7 * n^2$.&lt;/p&gt;

&lt;p&gt;É simples definir um limite inferior para qualquer função. Basta utilizar o expoente 0. Ou seja, todas as funções são $\Omega(1)$. Mais do que isso, podemos escolher expoentes menores. Por exemplo, a função $f(n) = n^2$ é $\Omega(n)$, $\Omega(log n)$ e $\Omega(1)$. Todavia, faz mais sentido escolhermos uma função com o mesmo expoente, porque a informação é mais precisa. Ou seja, se uma função é quadrática, dizemos que ela é $\Omega(n^2)$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Em termos simplistas, $f(n) \in \Omega(g(n))$ significa dizer que o crescimento de
f(n) é maior ou igual ao crescimento de g(n).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As duas notações restantes são $o$ (o minúsculo) e $\omega$ (omega minúsculo). Como disse, eu considero essas duas notações menos importantes que as demais e não vou discuti-las de forma aprofundada.&lt;/p&gt;

&lt;p&gt;** Apenas deixo aqui registrado que $o$ é muito semelhante à $O$, removendo apenas o sinal de igualdade da inequação:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0&lt;=f(n)&lt; c*g(n), \forall n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Ou seja, &lt;strong&gt;não&lt;/strong&gt; podemos dizer, por exemplo, que $f(n) = n^2 + 3$ é $o(n^2)$. $f(n) = n^2 + 3$ é $o(n^3)$, $o(n^4)$, $o(n^5)$ etc.&lt;/p&gt;

&lt;p&gt;Por outro lado, $\omega$ é muito semelhante à $\Omega$, removendo apenas o sinal de igualdade da inequação:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0 &lt;= c*g(n) &lt; f(n), n&gt;=n0$ &lt;/p&gt;

&lt;p&gt;Ou seja, &lt;strong&gt;não&lt;/strong&gt; podemos dizer, por exemplo, que $f(n) = n^3 + 2$ é $\omega(n^3)$. $f(n) = n^3 + 2$ é $\omega(n^2)$, $\omega(n)$, $\omega(log n)$ etc.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Este material foi inspirado nos Capítulos 3 e 4 do livro &amp;ldquo;Algoritmos: Teoria e Prática&amp;rdquo; de Cormen et. al.&lt;/p&gt;

&lt;p&gt;Para entender este material é muito importante ler a &lt;a class=&#34;external&#34; href=&#34;http://joaoarthurbm.github.io/eda/posts/introducao-a-analise/&#34;&gt; introdução à análise de algoritmos &lt;/a&gt;.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Análise de Algoritmos Recursivos</title>
         <link>https://joaoarthurbm.github.io/eda/posts/analise-algoritmos-recursivos/</link>
         <pubDate>Mon, 28 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/analise-algoritmos-recursivos/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Até aqui vimos como &lt;a href=&#34;http://joaoarthurbm.github.io/eda/posts/introducao-a-analise&#34; class=&#34;external&#34;&gt; analisar algoritmos iterativos&lt;/a&gt;, lembra? Esse processo pode ser resumido pelos seguintes passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;identificar operações primitivas;&lt;/li&gt;
&lt;li&gt;identificar a quantidade de vezes que cada uma dessas primitivas é executada;&lt;/li&gt;
&lt;li&gt;Somar essas execuções.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;
Você lembra quais são as operações primitivas?
    
    - Avaliação de expressões booleanas;
    - Operações matemáticas;
    - Retorno de métodos;
    - Atribuição;
    - Acesso à variáveis e posições arbitrárias de um array
&lt;/pre&gt;

&lt;p&gt;Seguindo esses passos sempre chegamos a uma função que descreve o tempo de execução do algoritmo. Vimos também que estamos interessados na ordem de crescimento dessa função, mais do que nos seus termos detalhados. Isto é, como se comporta a função para grandes valores de $n$. Assim, podemos aplicar as seguintes diretrizes para identificar a classe de complexidade das funções:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Eliminar constantes;&lt;/li&gt;
&lt;li&gt;Eliminar expoentes de menor magnitude.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Desse modo, a função $f(n) = 70n + 32n + 231$ tem ordem de crescimento linear. Isto é, $f(n) \in \Theta(n)$. Lembrando sempre que a maneira formal de demonstrar que $f(n) \in \Theta(n)$ é encontrar $c1$, $c2$ e $n0$, tal que:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; $0 &lt;= c1*n  &lt;= 70n + 32n + 231 &lt;= c2*n, \forall n &gt;=n0 $ &lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;o-problema&#34;&gt;O Problema&lt;/h1&gt;

&lt;p&gt;Acontece que, para algoritmos recursivos, a aplicação dos passos acima não é direta, pois um algoritmo recursivo é definido em termos dele mesmo. Vamos começar com uma função bem simples: fatorial.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; fatorial(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n&lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt;0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 1)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 1;
   &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
       &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; fatorial(n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1);
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vamos tentar aplicar os passos que aprendemos para a análise de algoritmos.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Identificando as primitivas.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;if (n==0 || n == 1)&lt;/code&gt; -&amp;gt; avaliação de expressão booleana.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return 1&lt;/code&gt; -&amp;gt; retorno de método.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;return n&lt;/code&gt; -&amp;gt; retorno de método.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*&lt;/code&gt; -&amp;gt; operação aritmética.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fatorial(n-1)&lt;/code&gt; -&amp;gt; ?&lt;/p&gt;

&lt;p&gt;Como vimos, para o caso em que as execuções não são em função de $n$ (caso acima) podemos simplificar as operações primitivas e suas execuções para (1).&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;O problema aqui é calcular o custo de fatorial(n-1).&lt;/p&gt;

&lt;p&gt;Qual o custo dessa operação e quantas vezes ela será executada? Não conseguimos responder essa questão de maneira direta como fizemos para os algoritmos iterativos porque trata-se de uma função definida em termos dela mesma. No nosso contexto, funções dessa natureza são chamadas de &lt;strong&gt;relações de recorrência&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;relação-de-recorrência&#34;&gt;Relação de Recorrência&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;Relação de recorrência é uma equação ou inequação que descreve uma função em termos dela mesma considerando entradas menores.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A função que descreve o tempo de execução de um algoritmo recursivo é dada por sua relação de recorrência. Vejamos a relação de recorrência que descreve o algoritmo de cálculo do fatorial:&lt;/p&gt;

&lt;p&gt;$T(n) = T(n-1) + \Theta(1)$,&lt;/p&gt;

&lt;p&gt;simplificando temos: $T(n) = T(n-1) + 1$&lt;/p&gt;

&lt;p&gt;Ou seja, o custo de calcular fatorial(n) é o custo de calcular fatorial(n-1) somado às primitivas que são executadas a cada passo da recursão que, nesse caso, representam 1.&lt;/p&gt;

&lt;p&gt;Nosso desafio então é resolver essa relação de recorrência para determinarmos o tempo de execução do algoritmo para cálculo do fatorial. Para isso, vamos utilizar o método da árvore de recursão.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;método-da-árvore-de-recursão&#34;&gt;Método da árvore de recursão&lt;/h1&gt;

&lt;p&gt;A ideia para resolver uma relação de recorrência é simular a sua execução através de uma árvore, onde os nós representam a entrada e as arestas representam a chamada recursiva.&lt;/p&gt;

&lt;h2 id=&#34;exemplo-fatorial&#34;&gt;Exemplo: Fatorial&lt;/h2&gt;

&lt;p&gt;Vamos entender como funciona esse recurso através de exemplos. Veja a árvore de recursão para o cálculo do fatorial de 5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;fatorial.png&#34; alt=&#34;fatorial&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que a raiz da árvore inicia com o valor 5, que é o tamanho da entrada. Note também que o custo do nível da entrada 5 é 1 (as primitivas). Este custo deve ser somado ao custo para a entrada 4 (chamada recursiva) que, por sua vez é 1. O cálculo da entrada 4 deve ser somado ao custo para a entrada 3 (chamada recursiva) e assim por diante. Veja que isso nada mais é do que a reprodução da relação de recorrência $T(n) = T(n-1) + 1$.&lt;/p&gt;

&lt;p&gt;Por fim, não é difícil compreender que o custo total é a soma dos custos de cada nível, ou seja, a soma dos custos de cada passo da recursão.&lt;/p&gt;

&lt;p&gt;Contudo, nosso trabalho aqui é definir o tempo de execução do algoritmo em função de uma entrada de tamanho n qualquer. Vamos, novamente, ilustrar a árvore de recursão para esse cenário:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;fatorialn.png&#34; alt=&#34;fatorialn&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Novamente, para calcular a função que define o tempo de execução desse algoritmo, precisamos somar os custos de cada nível. Isto é, somaremos o valor 1 uma quantidade de vezes representada por $h + 1$, onde $h$ é a altura da árvore e o +1 é o custo da última execução (&lt;code&gt;if n == 0 || n == 1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Portanto, precisamos definir $h$. Analisando a árvore, não é difícil notar que $h = n - 1$. Assim, temos que $f(n) = 1 * (n-1) + 1$, isto é, $f(n) = n$. Portanto, podemos dizer que $f(n) \in \Theta(n)$.&lt;/p&gt;

&lt;p&gt;Em resumo, podemos estabelecer os seguintes passos para analisar um algoritmo recursivo:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Estabelecer a relação de recorrência&lt;/li&gt;
&lt;li&gt;Expandir a árvore de execução baseado na relação de recorrência&lt;/li&gt;
&lt;li&gt;Determinar a altura h máxima da árvore&lt;/li&gt;
&lt;li&gt;Somar o custo de cada nível de execução&lt;/li&gt;
&lt;li&gt;Somar o custo total (soma do custo de todos os níveis)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;exemplo-mergesort&#34;&gt;Exemplo: MergeSort&lt;/h2&gt;

&lt;p&gt;Vamos analisar um exemplo um pouco mais complexo. O Merge Sort é um algoritmo de ordenação que, a cada execução parcial, efetua duas chamadas recursivas diminuindo pela metade o tamanho da entrada e um rotina (merge) cujo tempo de execução é dado por $\Theta(n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; mergeSort(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ini&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fim&lt;/span&gt;) {
	If (ini &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; fim) {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;meio&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ini &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fim) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2;
		mergeSort(v, ini, meio);
		mergeSort(v, meio &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1, fim);
		merge(v, ini, meio, fim);
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Relação de recorrência.&lt;/strong&gt; A primeira etapa para identificar a classe de complexidade do &lt;em&gt;Merge Sort&lt;/em&gt; é identificar a sua relação de recorrência:&lt;/p&gt;

&lt;p&gt;$T(n) = T(n/2) + T(n/2) + (n)$, simplificando&lt;/p&gt;

&lt;p&gt;$T(n) = 2 * T(n/2) + n$, onde n = v.length - 1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$2 * T(n/2)$ representa as duas chamadas recursivas em que a entrada é divida pela metade em cada uma delas.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$+ n$ representa o custo da função que une duas sequências já ordenadas em uma sequência ordenada. Não precisamos saber como isso é feito nesse momento, apenas precisamos saber que essa parte do algoritmo tem custo linear.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
Para fixar! Muitas relações de recorrência podem ser descritas 
na seguinte forma:

T(n) = a*T(n/b) + f(n)  , com a&gt;=1, b&gt;1 e f(n) não negativa. 

É importante que a gente saiba em português o que significa essa 
equação acima. Você lembra que ela é referente a um algoritmo 
recursivo, certo? Em português, dizemos que há a chamadas 
recursivas e que cada chamada recursiva divide a entrada em b 
partes. Além disso, a cada chamada recursiva, um custo f(n) é 
adicionado.
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Árvore de Recursão.&lt;/strong&gt; Vamos ilustrar a árvore de recursão gerada pela recorrência $T(n) = 2 T(n/2) + n$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;merge.png&#34; alt=&#34;merge&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Podemos notar que a árvore é um pouco diferente da que ilustramos para o fatorial. Em primeiro lugar, a árvore é binária. Sendo assim, o custo de um nível agora é calculado somando-se os custos de cada nó desse nível. Novamente, as arestas representam as duas chamadas recursivas de cada passo. Outra mudança é que cada nó filho diminui na metade o tamanho da entrada do nó pai. Essas duas últimas sentenças são resumidas por $2 * T (n/2)$. Por fim, cada nó tem o seu tempo de execução definido em função linear do tamanho da entrada. Essa última sentença é resumida pela parte final da relação de recorrência &amp;hellip;. $+n$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Função do tempo de execução.&lt;/strong&gt; Agora precisamos somar os custos de todos os níveis. Para isso, assim como no caso do fatorial, precisamos determinar a altura dessa árvore.&lt;/p&gt;

&lt;p&gt;Para o cálculo da altura podemos notar que a árvore irá parar de crescer quando $n / 2^h = 1$, pois o algoritmo atinge a condição de parada ini &amp;gt;= fim.&lt;/p&gt;

&lt;p&gt;Assim, temos que $2^h = n$. Aplicando $\log_{2}2$ nos dois lados da equação, temos:&lt;/p&gt;

&lt;p&gt;$h * \log_{2}2 = \log n$&lt;/p&gt;

&lt;p&gt;Simplificando, temos: $h = \log_{2}n$&lt;/p&gt;

&lt;p&gt;Agora que já definimos a altura da árvore, precisamos somar os custos parciais (de cada nível) uma quantidade de vezes representada pela altura da árvore. Cada nível tem custo $n$ (ex: $2 * n/2$, $4 * n/4$, $8 * n/8$&amp;hellip;). Se somarmos $n$ por 10 vezes, teremos $10*n$. Se somarmos $n$ por 100 vezes, teremos $100*n$. Como vamos somar $n$ por $\log n$ vezes, temos que o tempo de execução desse algoritmo é dado por $f(n) = n * \log n$. Naturalmente, só podemos fazer essa multiplicação porque cada nível tem o mesmo custo n.&lt;/p&gt;

&lt;p&gt;Então, temos que $T(n) =(n * \log n)$.&lt;/p&gt;

&lt;h2 id=&#34;exemplo-busca-binária&#34;&gt;Exemplo: Busca Binária&lt;/h2&gt;

&lt;p&gt;O algoritmo de busca binária é um algoritmo clássico de identificação da posição de um determinado elemento em uma sequência ordenada. A ideia é &amp;ldquo;palpitar&amp;rdquo; sempre a posição central. Caso o palpite seja maior do que o valor sendo procurado, o algoritmo descarta a metade à frente do palpite e passa a procurar na metade que contém os valores menores do que o palpite. Dessa maneira, a cada passo da recursão, são descartados metade dos elementos restantes. Esse procedimento torna a busca binária muito eficiente, quando comparada com a busca linear, que descarta apenas um elemento a cada iteração.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; indexOf(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ini&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fim&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ini &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; fim) {    
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;meio&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (ini &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; fim) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; 2;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (v[meio] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; meio;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; v[meio])
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; indexOf(v, n, ini, meio &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; indexOf(v, n, meio &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1, fim);
	} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Relação de recorrência.&lt;/strong&gt; Como aprendemos anteriormente, a primeira etapa para identificar o custo de execução do algoritimo de Busca Binária é identificar a sua relação de recorrência:&lt;/p&gt;

&lt;p&gt;$T(n) = T(n/2) + \Theta(1)$.&lt;/p&gt;

&lt;p&gt;Simplificando, $T(n) =  T(n/2) + 1$, onde n = v.length - 1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;$T(n/2)$ representa a chamada recursiva em que a entrada é divida pela metade. Importante notar aqui que, embora haja duas chamadas recursivas no código, apenas uma é executada a cada passo. Por isso temos $T(n/2)$ e não $2 * T(n/2)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$+ 1$ representa o custo da operação de cálculo do meio e da avaliação das expressões booleanas.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Árvore de Recursão. Vamos ilustrar a árvore de recursão gerada pela recorrência $T(n) = T(n/2) + 1$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;binaria.png&#34; alt=&#34;binaria&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Cada nó da árvore possui apenas uma aresta, porque há apenas uma chamada recursiva. Cada nível tem o seu custo constante (1), uma vez que a cada passo da recursão apenas algumas primitivas são executadas, como as avaliações das expressões booleanas e o cálculo da variável &lt;code&gt;meio&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Função do tempo de execução.&lt;/strong&gt; Agora precisamos somar os custos de todos os níveis. Para isso, assim como nos casos anteriores, precisamos determinar a altura dessa árvore.&lt;/p&gt;

&lt;p&gt;O cálculo da altura é exatamente o mesmo do realizado para o exemplo do Merge Sort. A árvore irá parar de crescer quando $n / 2^h = 1$, pois o algoritmo atinge a condição de parada &lt;code&gt;ini &amp;gt;= fim&lt;/code&gt;. Aplicando os mesmos passos do exemplo anterior, temos que a $h = \log n$&lt;/p&gt;

&lt;p&gt;Agora que já definimos a altura da árvore, precisamos somar os custos parciais (de cada nível) uma quantidade de vezes representada pela altura da árvore. Cada nível tem custo 1. Se somarmos 1 por 10 vezes, teremos $10*1$. Se somarmos 1 por 100 vezes, teremos $100*1$. Como vamos somar 1 por $\log n$ vezes, temos que o tempo de execução desse algoritmo é dado por $f(n) = 1 * \log n$, ou seja, $f(n) = \log n$. Naturalmente, só podemos fazer essa multiplicação porque cada nível tem o mesmo custo 1.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;método-mestre&#34;&gt;Método Mestre&lt;/h1&gt;

&lt;p&gt;O método iterativo utilizando a árvore de recursão é, de fato, uma boa alternativa para identificar a classe de complexidade de algoritmos recursivos. Além de ser um método analítico, ele tem propriedades didáticas importantes. Isto é, o exercício de ilustrar a árvore de recursão (execução) e, a partir dela, identificar o custo total do algoritmo é importante não somente para esse fim, mas para exercitar a capacidade de abstração e raciocínio do aluno. Contudo, muitas vezes, trata-se de um mecanismo laborioso. Nesse contexto, surge o &lt;strong&gt;Teorema Mestre&lt;/strong&gt; que nos permite identificar a classe de complexidade de um algoritmo aplicando apenas algumas operações matemáticas e comparando ordem de complexidade de funções.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E como o teorema funciona?&lt;/strong&gt; Primeiramente, é preciso que a relação de recorrência tenha determinadas propriedades. Vamos analisar concretamente essas propriedades:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$T(n) = a*T(n/b) + f(n)$&lt;/p&gt;

&lt;p&gt;Sendo $a&amp;gt;=1$, $b&amp;gt;1$ e $f(n)$ não negativa.&lt;/p&gt;

&lt;p&gt;Como vimos anteriormente, $a$ representa a quantidade de chamadas recursivas (quantidade de subproblemas), $b$ representa em quanto a entrada é diminuída a cada chamada recursiva e $f(n)$ representa o custo parcial de cada etapa da recursão. Para aplicar o Teorema Mestre, sua relação de recorrência deve ser na forma acima com $a &amp;gt;= 1$, $b &amp;gt; 1$ e $f(n)$ não negativa.&lt;/p&gt;

&lt;p&gt;Para esses casos, o Teorema Mestre é uma maneira direta de resolvermos a relação de recorrência. O Teorema Mestre estabelece que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Se f(n) &amp;lt; n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, então T(n) = theta(n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Se f(n) = n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, então T(n) = theta(f(n) * log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;n&lt;/sup&gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Se f(n) &amp;gt; n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, então T(n) = theta(f(n)).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Desse modo, se a relação de recorrência obedecer às restrições $a&amp;gt;=1$, $b&amp;gt;1$ e $f(n)$ não negativa, basta aplicarmos o teorema.&lt;/p&gt;

&lt;h3 id=&#34;exemplo&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Para a relação de recorrência $T(n) = 8 * T(n/2) + 1000 * n^2$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$a = 8$&lt;/li&gt;
&lt;li&gt;$b = 2$&lt;/li&gt;
&lt;li&gt;$f(n) = 1000 * n^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comparando $1000 * n^2$  com  n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;, temos que $1000 * n^2$ &amp;lt; $n^3$. Portanto, aplicando a primeira regra do Teorema Mestre, podemos afirmar que T(n) = theta(n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt;) e, portanto, $T(n) = (n^3)$.&lt;/p&gt;

&lt;h3 id=&#34;exemplo-1&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;$T(n) = 2 * T(n/2) + 10*n$&lt;/p&gt;

&lt;p&gt;Para a relação acima, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$a = 2$&lt;/li&gt;
&lt;li&gt;$b = 2$&lt;/li&gt;
&lt;li&gt;$f(n) = 10 * n$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comparando $10 * n$ com n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt; temos que $10 * n  =  n$, pois comparamos a ordem de grandeza das funções e, quando fazemos isso, as constantes não importam. Portanto, aplicando a segunda regra do Teorema Mestre, podemos afirmar que $T(n) = \Theta(n * \log_{2}n)$.&lt;/p&gt;

&lt;h3 id=&#34;exemplo-2&#34;&gt;Exemplo&lt;/h3&gt;

&lt;p&gt;Para $T(n) = 2 * T(n/2) + n^2$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$a = 2$&lt;/li&gt;
&lt;li&gt;$b = 2$&lt;/li&gt;
&lt;li&gt;$f(n) = n^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Comparando $n^2$  com n ** log&lt;sub&gt;b&lt;/sub&gt;&lt;sup&gt;a&lt;/sup&gt; temos que $n^2 &amp;gt; n$. Portanto, aplicando a terceira regra do Teorema Mestre, podemos afirmar que $T(n) = \Theta(f(n))$ e, portanto, $T(n) = \Theta(n^2)$.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Este material é um resumo superficial do Capítulo 4 do livro &amp;ldquo;Algoritmos: Teoria e Prática&amp;rdquo; de Cormen et. al.&lt;/p&gt;

&lt;p&gt;Há outras implementações de fatorial. Por exemplo, ao invés de checar se n == 0 ou n == 1, bastaria apenas checar se n == 0, 1 * 1 == 1. Dessa forma, a altura da árvore gerada teria uma unidade a mais. Contudo, isso não impacta na ordem de grandeza do algoritmo.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Ordenação por Comparação: Insertion Sort</title>
         <link>https://joaoarthurbm.github.io/eda/posts/insertion-sort/</link>
         <pubDate>Sun, 27 Oct 2019 01:01:01 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/insertion-sort/</guid>
         <description>

&lt;hr /&gt;

&lt;h1 id=&#34;direto-ao-ponto&#34;&gt;Direto ao ponto&lt;/h1&gt;

&lt;p&gt;O &lt;em&gt;Insertion Sort&lt;/em&gt; tem como rotina base a inserção ordenada. A ideia é executar várias vezes essa rotina para ordenar um array. Para ser exato, se executarmos $N - 1$ vezes a rotina de inserção ordenada em um array o resultado é a ordenação completa do mesmo. Por isso, vamos antes entender como funciona inserção ordenada.&lt;/p&gt;

&lt;h1 id=&#34;inserção-ordenada&#34;&gt;Inserção ordenada&lt;/h1&gt;

&lt;p&gt;Vamos analisar o caso de um array com $N$ elementos no qual os $N - 1$ primeiros elementos estão ordenados, mas o último elemento não está no seu lugar. Isto é, precisamos encaixar o último elemento de forma que a sequência fique ordenada. No exemplo abaixo, estamos falando em inserir de forma ordenada o valor 12.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;values =[9, 13, 16, 21, 32, &lt;font color=&#34;red&#34;&gt;12&lt;/font&gt;]&lt;/p&gt;

&lt;p&gt;Como a sequência está ordenada até o penúltimo índice, a ideia é comparar 12 com o valor anterior e, se 12 for menor, trocar esses valores. Essas comparações e trocas só devem parar quando 12 for maior que o elemento à esquerda ou quando 12 estiver na primeira posição do array. Para visualizar o Insertion Sort, alguns autores utilizam a metáfora de uma mão de cartas. Nesse contexto, o objetivo seria encaixar a carta 12 na mão já ordenada. Veja o passo a passo:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;values = [9, 13, 16, 21, &lt;font color=&#34;red&#34;&gt;12&lt;/font&gt;, 32]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [9, 13, 16, &lt;font color=&#34;red&#34;&gt;12&lt;/font&gt;, 21, 32]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [9, 13, &lt;font color=&#34;red&#34;&gt;12&lt;/font&gt;, 16, 21, 32]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [9, &lt;font color=&#34;red&#34;&gt;12&lt;/font&gt;, 13, 16, 21, 32]&lt;/p&gt;

&lt;p&gt;O código que implementa essa rotina está descrito abaixo. O índice &lt;code&gt;j&lt;/code&gt; assume o valor inicial &lt;code&gt;values.length - 1&lt;/code&gt; (última posição) e a condição de parada do laço é satisfeita quando esse índice alcançar 0 ou quando o valor que queremos inserir de forma ordenada já está na sua posição (&lt;code&gt;values[j] &amp;gt;= values[j-1]&lt;/code&gt;). Se &lt;code&gt;j&lt;/code&gt; alcançar 0, todo o array foi avaliado e o algoritmo deve parar. Da mesma forma, se &lt;code&gt;values[j] &amp;gt;= values[j-1]&lt;/code&gt; o algoritmo deve parar porque o elemento que estamos querendo encaixar já está em seu lugar.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; values.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; values[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; values[j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1]) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; values[j];
            values[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; values[j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1];
            values[j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
            j &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h1 id=&#34;insertion-sort&#34;&gt;Insertion Sort&lt;/h1&gt;

&lt;p&gt;A parte complexa desse algoritmo de ordenação nós já entendemos &amp;ndash; a inserção ordenada.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;O Insertion Sort aplica várias vezes a inserção ordenada para ordenar uma sequência.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vamos ver como isso é feito.&lt;/p&gt;

&lt;p&gt;Queremos ordenar $values = [7, 1, 2, 3, 9, 5, 1]$. Se pensarmos bem, podemos ver os dois primeiros elementos desse array como sendo o cenário apresentado na seção anterior, isto é, temos que $[7, 1]$ está ordenado, exceto pela última posição. Se aplicarmos inserção ordenada em $[7, 1]$, temos como resultado $[1, 7]$.&lt;/p&gt;

&lt;p&gt;Agora, vamos adotar a mesma postura com os três primeiros elementos: $[1, 7, 2]$. Novamente, podemos ver os 3 primeiros elementos como sendo o cenário para a inserção ordenada. Isto é $[1, 7, 2]$ está ordenado, exceto pelo último elemento. Se aplicarmos inserção ordenada em $[1, 7, 2]$, temos como resultado $[1, 2, 7]$.&lt;/p&gt;

&lt;p&gt;Depois, vamos adotar a mesma postura com os quatro primeiros elementos: $[1, 2, 7, 3]$. Isto é, está ordenado, exceto pelo último elemento. Então basta aplicarmos inserção ordenada de 3. O resultado é $[1, 2, 3, 7]$.&lt;/p&gt;

&lt;p&gt;Esse processo segue até o array ficar ordenado. Você percebeu que aplicamos inserção ordenada partindo do segundo elemento do array até o final? Isso significa que basta colocarmos um &lt;strong&gt;&lt;em&gt;loop&lt;/em&gt;&lt;/strong&gt; externo ao código de inserção ordenada, fazendo &lt;code&gt;j&lt;/code&gt; variar de 1 até o último elemento. Vamos ao código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;insertionSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;values&lt;/span&gt;) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; values.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) { 
		
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
	
		&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; values[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; values[j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1]) {
			&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; values[j];
			values[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; values[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1];
			values[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
			j &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
		}
	
	}	
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A única mudança que fizemos foi adicionar o comando &lt;strong&gt;&lt;em&gt;for&lt;/em&gt;&lt;/strong&gt; com &lt;code&gt;i&lt;/code&gt; variando de 1 até o final e &lt;code&gt;j&lt;/code&gt; variando de acordo com &lt;code&gt;i&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para fixar bem, veja a animação abaixo copiada &lt;a class=&#34;external&#34; href=&#34;https://medium.com/yay-its-erica/algorithms-for-beginners-bubble-sort-insertion-sort-merge-sort-29bd5506cc48&#34;&gt; deste material.&lt;/a&gt; Note que a ideia é sempre inserir um elemento em uma sequência já ordenada.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao.gif&#34; alt=&#34;animacao&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;propriedades-e-análise-de-eficiência&#34;&gt;Propriedades e Análise de eficiência&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;O Insertion Sort é estável, in-place e $O(n^2)$.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Estabilidade é uma propriedade relacionada à ordem relativa de valores iguais no array original. Por exemplo, se houver dois valores 97 no array antes da ordenação, após a execução do algoritmo, esses dois valores devem seguir a ordem relativa inicial. Ou seja, ao término da execução do algoritmo, a primeira ocorrência do 97 deve vir antes da segunda ocorrência do 97.&lt;/p&gt;

&lt;p&gt;O Insertion Sort é estável porque mantém a ordem relativa dos valores iguais. Isso ocorre porque as trocas são feitas sempre com vizinhos. Os valores vão sendo &amp;ldquo;afastados&amp;rdquo; um a um, e não dando saltos. Por isso, um elemento qualquer nunca trocará de posição com elementos de mesmo valor.&lt;/p&gt;

&lt;p&gt;O Insertion Sort é &lt;em&gt;in-place&lt;/em&gt; porque a ordenação é feita rearranjando os elementos no próprio array, ao invés de usar arrays ou outras estruturas auxiliares.&lt;/p&gt;

&lt;p&gt;O pior caso do Insertion Sort é um array ordenado em ordem reversa, pois toda tentativa de inserção ordenada deve percorrer o array todo à esquerda trocando os elementos até encaixar o atual na primeira posição. Veja o exemplo:&lt;/p&gt;

&lt;p&gt;Inserção ordenada de 20:
&lt;p align=&#34;center&#34;&gt;values = [90, &lt;font color=&#34;red&#34;&gt;20&lt;/font&gt;, 16, 5, 1]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [&lt;font color=&#34;red&#34;&gt;20&lt;/font&gt;, 90, 16, 5, 1]&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Inserção ordenada de 16:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;values = [20, 90, &lt;font color=&#34;red&#34;&gt;16&lt;/font&gt;, 5, 1]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [20, &lt;font color=&#34;red&#34;&gt;16&lt;/font&gt;, 90, 5, 1]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [&lt;font color=&#34;red&#34;&gt;16&lt;/font&gt;, 20, 90, 5, 1]&lt;/p&gt;

&lt;p&gt;Inserção ordenada de 5:
&lt;p align=&#34;center&#34;&gt;values = [16, 20, 90, &lt;font color=&#34;red&#34;&gt;5&lt;/font&gt;, 1]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [16, 20, &lt;font color=&#34;red&#34;&gt;5&lt;/font&gt;, 90, 1]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [16, &lt;font color=&#34;red&#34;&gt;5&lt;/font&gt;, 20, 90, 1]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [&lt;font color=&#34;red&#34;&gt;5&lt;/font&gt;, 15, 20, 90, 1]&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Inserção ordenada de 1:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;values = [5, 15, 20, 90, &lt;font color=&#34;red&#34;&gt;1&lt;/font&gt;]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [5, 15, 20, &lt;font color=&#34;red&#34;&gt;1&lt;/font&gt;, 90]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [5, 15, &lt;font color=&#34;red&#34;&gt;1&lt;/font&gt;, 20, 90]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [5, &lt;font color=&#34;red&#34;&gt;1&lt;/font&gt;, 15, 20, 90]&lt;/p&gt;
&lt;p align=&#34;center&#34;&gt;values = [&lt;font color=&#34;red&#34;&gt;1&lt;/font&gt;, 5, 15, 20, 90]&lt;/p&gt;

&lt;p&gt;Feito. Array ordenado.&lt;/p&gt;

&lt;p&gt;Note que o tempo de execução é dado pela soma dos passos de cada iteração. Essa soma pode ser representada por $1 + 2 + 3 + &amp;hellip; (n - 1)$, ou seja, uma Progressão Aritmética Finita (PA) com $a_1 = 1$ e $a_n = (n - 1)$ e razão $r=1$. A soma dos termos de uma PA é dada por: $(a_1+a_n)*n/2$. Então, temos que o tempo de execução do algoritmo é dado por $(1 + (n - 1)) * n/2 = (n^2)/2$. Aplicando as diretrizes de simplificação, o Insertion Sort é $\Theta(n^2)$.&lt;/p&gt;

&lt;p&gt;É importante destacar que o Insertion Sort não é considerado um algoritmo eficiente para grandes entradas. Há alternativas $O(n*\log n)$, como Quick Sort e Merge Sort, além de alternativas lineares como o &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/&#34;&gt;Counting Sort&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;resumo&#34;&gt;Resumo&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;O Insertion Sort nada mais é do que a execução do algoritmo de inserção ordenada repetidas vezes.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O Insertion Sort é in-place, estável e $O(n^2)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O pior caso da execução deste algoritmo manifesta-se quando a entrada está ordenada em ordem decrescente.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Capítulos 2 do livro “Algoritmos: Teoria e Prática” de Cormen et. al. aborda este mesmo assunto com profundidade. Em particular, a análise de eficiência é discutida com mais detalhes.&lt;/p&gt;

&lt;p&gt;Vale a pena utilizar o &lt;a class=&#34;external&#34; href=&#34;https://visualgo.net/en/sorting&#34;&gt;VisuAlgo&lt;/a&gt; para visualizar a execução do Insertion Sort e de outros algoritmos de ordenação.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Ordenação Linear</title>
         <link>https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/</link>
         <pubDate>Sun, 27 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Os algoritmos de ordenação que vimos até então utilizam comparação para estabelecer a ordem entre os elementos de uma sequência. Primeiro vimos três algoritmos $\Theta(n^2)$: Selection Sort, Insertion Sort e Bubble Sort. Depois vimos alguns algoritmos $\Theta(n * \log n)$: Merge Sort e Quick Sort&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Importante-lembr&#34;&gt;&lt;a href=&#34;#fn:Importante-lembr&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Neste material vamos abordar algoritmos que não utilizam comparação, mas que são muito eficientes do ponto de vista de tempo de execução, embora demandem substancialmente mais memória do que o Selection Sort, Insertion Sort, Quick Sort etc.&lt;/p&gt;

&lt;h1 id=&#34;ordenação-por-contagem&#34;&gt;Ordenação por Contagem&lt;/h1&gt;

&lt;p&gt;Algo que chama a atenção em um primeiro momento é:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;b&gt;Como é possível ordenar elementos sem utilizar comparação?&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Em geral, a ideia é valer-se do fato de que estamos ordenando números inteiros e que os índices dos arrays também são inteiros. Dessa maneira, podemos mapear o valor presente em uma sequência para a posição de mesmo valor em um array auxiliar (&lt;code&gt;array[i] = i&lt;/code&gt;). Essa é a estratégia geral dos algoritmos de ordenação linear que se baseiam na contagem dos elementos da sequência a ser ordenada.&lt;/p&gt;

&lt;p&gt;Antes de analisarmos os algoritmos de contagem em detalhes, vamos abordar um exemplo bem simples para entender esse conceito. Para isso, vamos entrar em um mundo em que:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;todos os elementos do array que vamos ordenar são inteiros positivos (1, 2, 3…k);&lt;/li&gt;
&lt;li&gt;não há repetição de elementos no array que vamos ordenar;&lt;/li&gt;
&lt;li&gt;sabemos o maior valor desse array, o qual chamamos de k.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Desse modo, se quisermos ordenar o array $A = [7, 2, 1, 4]$&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:O-ideal-nomear-v&#34;&gt;&lt;a href=&#34;#fn:O-ideal-nomear-v&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;, basta criarmos um array auxiliar $C$ cujo tamanho é $k$, onde $k$ é o maior elemento do array original (7), e iterarmos sobre $A$ registrando a presença de seus elementos em $C$ através da seguinte instrução &lt;code&gt;C[A[i] - 1] = true&lt;/code&gt;. O índice é subtraído de 1, pois as posições de um array em Java iniciam-se de 0.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[k];

&lt;span style=&#34;color:#75715e&#34;&gt;// registrando a presença de A[i] na sequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Se $A = [7, 2, 1, 4]$, com $k = 7$, temos $C$ preenchido da seguinte maneira:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C = [&lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;]&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Agora, se criarmos um array $B$ do tamanho de $A$ e iterarmos sobre o array $C$ preenchendo $B$ com o valor do índice $i + 1$ em que &lt;code&gt;C[i] == true&lt;/code&gt;, temos que $B$ é a versão ordenada de $A$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (C[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;) {
        B[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;
        j &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Assim, para $A = [7, 2, 1, 4]$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C = [&lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;]&lt;/li&gt;
&lt;li&gt;B = [1, 2, 4, 7], representando a sequência de valores de $A$, porém ordenada.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Viu como foi fácil? Note que $B$ foi preenchido com os valores de $i+1$ em que C[i] ==  true. Ou seja, $B[0] = 1$, pois C[0] ==  true. $B[1] = 2$, pois C[1] ==  true. $B[2] = 4$, pois C[3] ==  true. Por fim, $B[3] = 7$, pois C[6] ==  true.&lt;/p&gt;

&lt;p&gt;Vamos unir os trechos de código mostrados acima em um método que recebe $A$ e $k$ e retorna um array $B$ que representa a ordenação dos elementos de $A$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;sort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;) {
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;boolean&lt;/span&gt;[k];

    &lt;span style=&#34;color:#75715e&#34;&gt;// registrando a presença de A[i] na sequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    }
   
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (C[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;) {
            B[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;
            j &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; B;   
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;mais-um-exemplo-a-9-1-3-4-6-7&#34;&gt;Mais um exemplo: A = [9, 1, 3, 4, 6, 7]&lt;/h3&gt;

&lt;p&gt;Sempre lembrando que sabemos o valor de $k$ e que não há repetição dos elementos a serem ordenados.&lt;/p&gt;

&lt;p&gt;Para $A = [9, 1, 3, 4, 6, 7]$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C = [&lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false, &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;,  &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;, false,  &lt;span style=&#34;color:blue&#34;&gt;true&lt;/span&gt;]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;B = [1, 3, 4, 6, 7, 9], representando a sequência de valores de $A$, porém ordenada.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;counting-sort-e-se-houver-repetição-no-array&#34;&gt;Counting Sort: E se houver repetição no array?&lt;/h2&gt;

&lt;p&gt;Repetição de valores em um array a ser ordenado não é um cenário incomum, certo? O fato de não haver repetição nos permitiu criar um array C de booleanos e registrar a presença ou não de um elemento.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;O que faríamos se houvesse repetição?&lt;/p&gt;

&lt;p&gt;Daí surge ordenação por contagem (&lt;em&gt;Counting Sort&lt;/em&gt;). A ideia geral é registrar a frequência dos elementos ao invés da simples presença. Isso faz com que o array $C$ passe a ser um array de inteiros, não de booleanos. O algoritmo do &lt;em&gt;Counting Sort&lt;/em&gt; é baseado na ideia que vimos, mas possui algumas modificações substanciais para permitir elementos repetidos e para manter a estabilidade. Em linhas gerais, o &lt;em&gt;Counting Sort&lt;/em&gt; possui os seguintes passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;registrar a frequência dos elementos de $A$ no array $C$;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Calcular a soma cumulativa de $C$. Esse passo registra, para cada elemento $x$ da entrada, o número de elementos menores ou iguais a $x$;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iterar sobre $A$ do fim ao início registrando em $B$ o valor de $A$ com a seguinte instrução &lt;code&gt;B[C[A[i] - 1] -1] = A[i]&lt;/code&gt;. Não se assuste. Essa sequência de decrementos em 1 é devido ao fato de começarmos os índices de um array a partir de zero em Java.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Antes de entrarmos nos detalhes de código do algoritmo, vamos simular a execução de um exemplo.&lt;/p&gt;

&lt;h3 id=&#34;exemplo-a-1-9-1-3-4-7-6-7&#34;&gt;Exemplo: A = [1, 9, 1, 3, 4, 7, 6, 7]&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Passo 1: Contagem de frequência em C.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[k];

        &lt;span style=&#34;color:#75715e&#34;&gt;// frequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Para  $A = [1, 9, 1, 3, 4, 7, 6, 7]$ e $k = 9$, temos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;C = [2, 0, 1, 1, 0, 1, 2, 0, 1], isto é, no array a ser ordenado há dois elementos de valor 1, nenhum elemento de valor 2, um elemento de valor 3 e assim por diante.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 2: Soma cumulativa em C.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
        &lt;span style=&#34;color:#75715e&#34;&gt;// cumulativa
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[i] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; C[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1];
        }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Para $C = [2, 0, 1, 1, 0, 1, 2, 0, 1]$, após a execução do cálculo da cumulativa, temos $C = [2, 2, 3, 4, 4, 5, 7, 7, 8]$, isto é, no array a ser ordenado há:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2 elementos menores ou igual a 1&lt;/li&gt;
&lt;li&gt;2 elementos menores ou iguais a 2&lt;/li&gt;
&lt;li&gt;3 elementos menores ou iguais a 3&lt;/li&gt;
&lt;li&gt;4 elementos menores ou iguais a 4&lt;/li&gt;
&lt;li&gt;4 elementos menores ou iguais a 5&lt;/li&gt;
&lt;li&gt;5 elementos menores ou iguais a 6&lt;/li&gt;
&lt;li&gt;7 elementos menores ou iguais a 7&lt;/li&gt;
&lt;li&gt;7 elementos menores ou iguais a 8&lt;/li&gt;
&lt;li&gt;8 elementos menores ou iguais a 9.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Passo 3: Iterar do fim ao início de $A$ registrando em $B$ os elementos.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
            B[C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i];
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
        }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Essa parte pode ser confusa e acredito que para entendê-la precisamos de recursos visuais melhores do que o texto. Por isso, fiz o vídeo abaixo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=3bm7NgKJpj4&amp;feature=youtu.be&#34;&gt;
    &lt;img src=&#34;video.jpg&#34;&gt;
&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;implementação-do-counting-sort&#34;&gt;Implementação do Counting Sort&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;countingSort&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;) {
    
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[k];

        &lt;span style=&#34;color:#75715e&#34;&gt;// frequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        }
        
        &lt;span style=&#34;color:#75715e&#34;&gt;// cumulativa
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; C.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            C[i] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; C[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1];
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;];

        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
            B[C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i];
            C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
        }

        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; B;
    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;análise-do-counting-sort&#34;&gt;Análise do Counting Sort&lt;/h2&gt;

&lt;p&gt;O Counting Sort tem em sua implementação 3 laços principais. O primeiro percorre o array $A$ (tamanho $n$), o segundo percorre o array $C$ (tamanho $k$) e o terceiro percorre novamente o array $A$. Assim, temos:&lt;/p&gt;

&lt;p&gt;$T(n) = 2n + k$. Aplicando as diretrizes para análise assintótica, temos:
$T(n) = (n + k)$.&lt;/p&gt;

&lt;p&gt;O importante aqui é entender que o algoritmo tem seu tempo de execução linear em função do tamanho de $n$ e $k$, não somente do tamanho de $n$. Esse tempo de execução é substancialmente mais eficiente do que os outros algoritmos que vimos. Contudo, esse algoritmo também tem um custo associado ao uso de memória, pois precisa criar um array de contagem $C$ de tamanho igual a $k$ e o array $B$ a ser retornado de tamanho igual ao do array original. Ou seja, do ponto de vista de memória, também que o consumo é dado por $T(n) = (n + k)$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O que acontece se k for muito maior que n?&lt;/strong&gt; Vejamos um exemplo:&lt;/p&gt;

&lt;p&gt;$A = [1, 3, 2, 1, 9874392]$&lt;/p&gt;

&lt;p&gt;Veja que teríamos que criar o array de contagem $C$ de tamanho 9874392 mesmo tendo que ordenar apenas 5 elementos, o que seria muito ruim.&lt;/p&gt;

&lt;p&gt;Por outro lado, o que acontece se $k$ for muito menor que $n$? Vejamos um exemplo:&lt;/p&gt;

&lt;p&gt;A = [1, 3, 2, 1, 1, 5, 3, 2, 5, 4, 2, 1, 2, 1, 1, 2, 1, 4, 5, 2, 2, 3, 2]&lt;/p&gt;

&lt;p&gt;Veja que teríamos que criar o array de contagem C de tamanho 5 para ordenar um array com 23 elementos.  Isso pode ser ainda mais vantajoso se imaginarmos um cenário em que teremos, por exemplo, que ordenar todas as pessoas do mundo de acordo com sua idade. Nesse caso, temos um conjunto muito grande de dados (~7.7 bilhões), mas com um $k$ bem menor, pois a pessoa mais velha do mundo não ultrapassaria, nos dias de hoje, 125 anos. Isto é, $k$ é muito menor do que $n$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E se eu quiser usar o Counting Sort para ordenar sequências contendo valores iguais a zero e valores negativos?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;O Counting Sort baseia-se na ideia de que um valor inteiro pode ser mapeado para o índice de mesmo valor em um array auxiliar. Essa estratégia nos impede, em um primeiro momento, de ordenar uma sequência com números negativos, pois o menor índice em um array é 0. Além disso, na nossa implementação inicial excluímos também elementos iguais a zero. Contudo, é possível fazer algumas mudanças simples no Counting Sort para que o mesmo passe a também ordenar sequências com esses valores.&lt;/p&gt;

&lt;p&gt;A ideia é simples: basta identificarmos o menor elemento do array (menor) e usar esse valor como um &amp;ldquo;salto&amp;rdquo; para adicionar os elementos. É uma ideia similar a fazer um shift para a direita em todos os elementos. O menor elemento array tem sua frequência registrada na posição zero. Vamos ver um exemplo:&lt;/p&gt;

&lt;p&gt;$A = [1,-3, 2, 1, 7]$, com k = 7 e menor = -3.&lt;/p&gt;

&lt;p&gt;Em primeiro lugar, o array de contagem $C$ já não varia de 0 a $k$, mas sim de 0 a $k - menor + 1$, porque temos que considerar que a frequência do elemento de valor -3 será registrada na posição 0, a do valor -2, na posição 1, a do valor -1 na posição 0 e assim por diante. Por isso, quando for preciso mapear os elementos de A em C e B, temos que usar o salto de |menor| (3, no nosso exemplo). O cálculo da frequência seria dado pelo seguinte código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[maior &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; menor &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1];

    &lt;span style=&#34;color:#75715e&#34;&gt;// frequência
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        C[A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; menor] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Para A = [1,-3, 2, 1, 7], temos C = [1, 0, 0, 0, 2, 1, 0, 0, 0, 0, 1]. Note que o primeiro índice é reservado para a frequência do menor elemento (-3) e não mais para 1. Além disso, como estamos também contando com a presença de elementos de valor 0 no array, trocamos a instrução &lt;code&gt;C[A[i] - 1] += 1&lt;/code&gt; por &lt;code&gt;C[A[i] - menor] += 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A mesma mudança é considerada no restante da implementação, sempre aplicando &lt;code&gt;array[i]- menor&lt;/code&gt; para considerar o salto.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Este material não é tão completo quanto o livro texto da disciplina. Sugiro também a leitura do Capítulo 8 do livro &amp;ldquo;Algoritmos: Teoria e Prática&amp;rdquo; de Cormen et. al.&lt;/p&gt;

&lt;p&gt;No curso de Estrutura de Dados da UFCG há ainda a discussão de outros algoritmos de ordenação linear, como o Radix Sort e o Bucket Sort.&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Importante-lembr&#34;&gt;Importante lembrar que o Quick Sort no pior caso tem seu tempo de execução descrito por uma função quadrática. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Importante-lembr&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:O-ideal-nomear-v&#34;&gt; O ideal é nomear variável com letra minúscula em Java. Contudo, para fins didáticos, utilizaremos letras maiúsculas. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:O-ideal-nomear-v&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Listas Baseadas em Arrays (ArrayList)</title>
         <link>https://joaoarthurbm.github.io/eda/posts/arraylist/</link>
         <pubDate>Sat, 26 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/arraylist/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Array é a primeira estrutura de dados que abordamos na disciplina. Há razões para essa escolha. Em primeiro lugar, arrays estão presentes na biblioteca padrão de grande parte das linguagens de programação. Além disso, também são estruturas simples e eficientes. Por último, outras estruturas mais complexas baseiam sua implementação em arrays, como é o caso de ArrayList, assunto deste material.&lt;/p&gt;

&lt;p&gt;Antes de partirmos para os detalhes de ArrayList, vamos destacar algumas desvantagens na manipulação de arrays que nos motivam a construir ArrayList. Todas essas desvantagens compartilham um incômodo comum: o programador deve ser responsável por diversas verificações e operações adicionais para manter a consistência do array. Vejamos:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O array possui tamanho fixo.&lt;/strong&gt; Caso seja preciso armazenar mais elementos, é preciso criar um outro e transferir os elementos do array original para esse novo array. Isso não é algo que o programador queira se preocupar sempre. Por isso é preciso que isso seja feito de forma transparente para quem deseja usar uma estrutura de dados que cresce &amp;ldquo;dinamicamente&amp;rdquo;. O tamanho fixo também implica dizer que nem sempre a quantidade de elementos presentes no array é igual a sua capacidade. Por isso, o programador também tem que controlar quantas posições estão, de fato, sendo utilizadas.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Não é possível remover uma posição do array.&lt;/strong&gt; O que fazemos, normalmente, é atribuir aquela posição para null. Contudo, isso cria um &amp;ldquo;buraco&amp;rdquo; no array. O programador deve decidir se afasta todos os outros objetos para a esquerda ou se convive com aquele &amp;ldquo;buraco&amp;rdquo;. Conviver nesse contexto significa espalhar pelo código verificações como &lt;code&gt;if alunos[i] != null&lt;/code&gt;. Novamente, idealmente o programador não precisaria se preocupar com isso. Isso deveria ser transparente para quem está usando uma estrutura de dados.&lt;/p&gt;

&lt;p&gt;Então, em resumo, como já vimos no passado, array é uma estrutura eficiente da qual queremos tirar proveito, mas muitas das preocupações que estão incluídas no seu uso podem ser transparentes para o programador. Essa é a proposta da classe ArrayList: fornecer uma API com operações de uma lista, mas esconder detalhes como remanejamento de elementos na remoção, aumento da capacidade da estrutura na adição de elementos, entre outras tarefas.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;arraylist&#34;&gt;ArrayList&lt;/h1&gt;

&lt;p&gt;Para fins didáticos, neste material vamos construir uma lista baseada em arrays que armazena objetos do tipo Aluno. O objeto do tipo Aluno possui dois atributos: matrícula e nome. A partir de agora, instâncias desse tipo serão representadas pela notação (matrícula, nome), por exemplo, (123, &amp;ldquo;Cartola&amp;rdquo;).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; Aluno {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Integer&lt;/span&gt; matricula;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; nome;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Integer&lt;/span&gt; getMatricula() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;matricula&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; getNome() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;nome&lt;/span&gt;;
    }
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;organização-interna-atributos-constantes-e-construtores&#34;&gt;Organização interna: atributos, constantes e construtores&lt;/h2&gt;

&lt;p&gt;Vamos lá.  Em primeiro lugar, vamos dar uma olhada na definição da classe, seus atributos e construtores:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; ArrayList {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt;[] lista;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; CAPACIDADE_DEFAULT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 20;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; tamanho;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ArrayList&lt;/span&gt;() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;(CAPACIDADE_DEFAULT);
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ArrayList&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;capacidade&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[capacidade];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    }

           ...

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Um objeto do tipo ArrayList possui dois atributos: o array &lt;strong&gt;&lt;em&gt;lista&lt;/em&gt;&lt;/strong&gt;, que armazena os objetos e o inteiro &lt;em&gt;tamanho&lt;/em&gt;, que representa a quantidade de elementos presente na lista. A classe ArrayList possui também uma constante &lt;strong&gt;&lt;em&gt;CAPACIDADE_DEFAULT&lt;/em&gt;&lt;/strong&gt; que define em 20 a capacidade inicial da lista, caso o programador não queira redefini-la. Por fim, dois construtores são definidos: um padrão, caso o programador não queira redefinir o tamanho inicial da lista e um recebendo como parâmetro a capacidade desejada.&lt;/p&gt;

&lt;h2 id=&#34;operações-básicas-inserção-remoção-e-busca&#34;&gt;Operações básicas: inserção, remoção e busca.&lt;/h2&gt;

&lt;h3 id=&#34;inserção&#34;&gt;Inserção&lt;/h3&gt;

&lt;p&gt;Há três formas de se inserir um elemento em uma ArrayList:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;boolean add(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void add(int index, Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void set(int index, Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Todas, naturalmente, recebem como parâmetro o elemento a ser adicionado. A primeira não requer um índice específico e, por isso, assume que a inserção do novo elemento deve ser feita no fim da lista, isto é, na próxima posição livre do array. As outras duas formas requerem o índice &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; em que a operação deve ser realizada. A diferença entre essas duas últimas é que uma inclui o novo elemento na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; e desloca os elementos à frente uma posição para a direita, enquanto a outra altera o valor da posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Há uma preocupação interna para os métodos 1 e 2. Para ambos, é preciso checar se o array já não está completamente preenchido. Caso isso seja verdade, precisamos criar um novo array, adicionar todos os elementos do array original nesse novo array e aí sim inserir o novo elemento. Estamos chamando essa rotina de &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Para o método 2 precisamos também deslocar os elementos a frente da posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; para a direita (&lt;strong&gt;&lt;em&gt;shiftParaDireita()&lt;/em&gt;&lt;/strong&gt;) para então incluir o elemento na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Por fim, as estratégias 2 e 3 precisam verificar se o índice a ser alterado é válido ou não, isto é, se está dentro dos limites da lista.&lt;/p&gt;

&lt;p&gt;Vamos ao código.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; add(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        assegureCapacidade(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
    }
    

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; add(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
        assegureCapacidade(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1);
        
        shiftParaDireita(index);
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[index] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; set(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[index] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; shiftParaDireita(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; index; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1];
        }
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Estamos tentando seguir o padrão da API de Java para a assinatura dos métodos. Por isso o primeiro método retorna um booleano para indicar se a adição foi feita ou não. Pode parecer estranho porque o retorno é sempre &lt;strong&gt;&lt;em&gt;true&lt;/em&gt;&lt;/strong&gt;, mas isso faz sentido porque essa assinatura é herdada do contrato da interface &lt;strong&gt;&lt;em&gt;List&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;É importante discutir a chamada ao método &lt;strong&gt;&lt;em&gt;assegureCapacidade(int capacidadePretendida)&lt;/em&gt;&lt;/strong&gt;. Por ser baseada em array, uma &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt; é limitada ao tamanho do array definido inicialmente. Caso queira crescer dinamicamente, é preciso checar se há a capacidade pretendida e, se não houver, realizar o resize. Isto é, criar um novo array e transferir os elementos do array inicial para o novo. Ambos os métodos são privados, pois a ideia é que essas preocupações sejam internas e transparentes ao usuário de uma &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt;. Vamos ver como isso é feito:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; assegureCapacidade(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;capacidadePretendida&lt;/span&gt;) {    
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (capacidadePretendida &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;)
            resize(Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; 2, capacidadePretendida));
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; resize(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;novaCapacidade&lt;/span&gt;) {
        Aluno[] &lt;span style=&#34;color:#a6e22e&#34;&gt;novaLista&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno[novaCapacidade];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            novaLista[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; novaLista;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;assegureCapacidade.&lt;/strong&gt; Este método verifica se a nova capacidade pretendida é atendida pelo tamanho atual da lista. Caso não seja, o método invoca &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; para criar uma nova lista cujo tamanho o máximo entre o dobro da lista original ou a capacidade nova pretendida. Esse cálculo do máximo entre os dois é feito porque queremos evitar realizar muitos &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; e, por isso, fazemos um &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; de no mínimo o dobro do tamanho original.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;resize.&lt;/strong&gt; Este método cria um novo array e transfere os elementos do array original para ele.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;análise de desempenho&lt;/strong&gt; dessas operações precisa levar em consideração dois fatores: o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; e o &lt;strong&gt;&lt;em&gt;shiftParaADireita()&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Não podemos afirmar que o método &lt;strong&gt;&lt;em&gt;add(Aluno aluno)&lt;/em&gt;&lt;/strong&gt; é executado em tempo constante, mesmo que grande parte das vezes isso seja verdade. Por exemplo, para uma lista de tamanho original 20, as 20 primeiras adições são executadas em tempo constante, mas a 21 primeira precisa executar o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt;, que é realizado em $O(n)$, pois envolve iterar por todo o array antigo e transferir os elementos para o novo array. Contudo, também não podemos dizer que o método &lt;strong&gt;&lt;em&gt;add(Aluno aluno)&lt;/em&gt;&lt;/strong&gt; é $O(n)$, pois o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; é executado apenas quando o limite é alcançado. Nesse caso, dizemos a operação é $O(1)$ amortizado, ou seja, o custo para adicionar $n$ elementos na lista é $O(n)$.&lt;/p&gt;

&lt;p&gt;Para a análise do método &lt;strong&gt;&lt;em&gt;add(int index, Aluno aluno)&lt;/em&gt;&lt;/strong&gt; temos que levar em consideração que o &lt;strong&gt;&lt;em&gt;shiftParaADireita&lt;/em&gt;&lt;/strong&gt; no pior caso é $O(n)$. Esse pior caso se manifesta quando queremos adicionar um elemento no índice 0 da lista. Assim, teríamos que iterar sobre todo o array deslocando os elementos para frente.&lt;/p&gt;

&lt;h3 id=&#34;remoção&#34;&gt;Remoção&lt;/h3&gt;

&lt;p&gt;Há duas formas de se remover um elemento em uma &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt;: pelo índice e pelo valor.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;remove(int index)&lt;/li&gt;
&lt;li&gt;remove(Aluno aluno)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Ambos precisam rearranjar os elementos para não deixar &amp;ldquo;buracos&amp;rdquo; na lista. Chamamos essa rotina de &lt;strong&gt;&lt;em&gt;shiftParaEsquerda&lt;/em&gt;&lt;/strong&gt;. A diferença é que o método 2 precisa procurar o elemento antes de realizar o &lt;em&gt;shift&lt;/em&gt;. Veja o exemplo abaixo para entender o porquê de termos que afastar para a esquerda todos os elementos à frente do removido.&lt;/p&gt;

&lt;p&gt;$lista = [9, 2, 1, 8, 24, 3, -7]$, com tamanho = 7.&lt;/p&gt;

&lt;p&gt;Se quisermos remover o elemento no índice 2, precisamos afastar para a esquerda os elementos à frente e atualizar, naturalmente, a variável &lt;strong&gt;&lt;em&gt;tamanho&lt;/em&gt;&lt;/strong&gt;. Após a execução do método &lt;strong&gt;&lt;em&gt;remove(2)&lt;/em&gt;&lt;/strong&gt;, temos a lista nas seguintes condições:&lt;/p&gt;

&lt;p&gt;$lista = [9, 2, 8, 24, 3, -7, -7]$, com $tamanho = 6$, isto é, a última posição (6) passa a estar livre para uma nova adição, caso seja preciso. Perceba que os índices 0 e 1 ficaram inalterados e, a partir disso, o índice $i$ passou a receber o valor em $i+1$. Note também que o último índice fica com o valor anterior, mas ele não faz parte da lista, pois os limites são 0 e $tamanho - 1$. Vamos ao código.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...           
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        
        Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(index);
        
        shiftParaEsquerda(index);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; remove(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aluno &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i].&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno)) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;(i);
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
            }
        }
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; shiftParaEsquerda(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; index; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;1];
        }
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Novamente, a preocupação em rearranjar os elementos é exclusiva de quem desenvolveu a lista, não de quem está usando-a.&lt;/p&gt;

&lt;p&gt;Como a remoção envolve realocar todos os elementos à frente do removido para a esquerda, a operação, no pior caso, é $O(n)$. Esse pior caso se manifesta quando queremos remover o primeiro elemento da lista.&lt;/p&gt;

&lt;h3 id=&#34;busca&#34;&gt;Busca&lt;/h3&gt;

&lt;p&gt;De um modo geral, podemos dizer que há 3 cenários de busca: i) quando queremos acessar o elemento em um determinado índice; ii) quando queremos encontrar o índice em que um elemento está e iii) quando queremos verificar a presença de um elemento na lista. Essas aspirações podem ser satisfeitas pelos seguintes métodos:&lt;/p&gt;

&lt;p&gt;Aluno get(int index)
int indexOf(Aluno aluno)
boolean contains(Aluno aluno)&lt;/p&gt;

&lt;p&gt;O método 1 é executado em tempo constante O(1), pois o índice é fornecido como parâmetro. A única preocupação é verificar se o índice é válido ou não.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tamanho&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[index];
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Os outros dois métodos são instâncias de busca linear $(O(n))$, pois devem iterar sobre a lista procurando pelo objeto passado como parâmetro.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...            
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; indexOf(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; tamanho; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;lista&lt;/span&gt;[i].&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno))
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; i;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; contains(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indexOf&lt;/span&gt;(aluno) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O método &lt;strong&gt;&lt;em&gt;indexOf&lt;/em&gt;&lt;/strong&gt; itera sobre a lista procurando um elemento igual ao passado como parâmetro. Se encontrar, retorna o índice desse elemento. Ou seja, se houver mais de uma ocorrência do valor procurado, o índice da primeira ocorrência é retornado. Caso contrário, retorna -1.&lt;/p&gt;

&lt;p&gt;O método &lt;strong&gt;&lt;em&gt;contains&lt;/em&gt;&lt;/strong&gt; utiliza a rotina efetuada pelo método &lt;strong&gt;&lt;em&gt;indexOf&lt;/em&gt;&lt;/strong&gt;. Caso o índice retornado seja igual a -1, retorna &lt;em&gt;false&lt;/em&gt;. Caso contrário, retorna &lt;em&gt;true&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Por motivos de simplificação, a classe &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt; que implementamos neste material implementa uma lista baseada em arrays para manipular objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;. Naturalmente, por ser de propósito geral, a implementação de Java de &lt;strong&gt;&lt;em&gt;ArrayList&lt;/em&gt;&lt;/strong&gt; permite o armazenamento e manipulação de qualquer objeto.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Listas Ligadas (LinkedList)</title>
         <link>https://joaoarthurbm.github.io/eda/posts/linkedlist/</link>
         <pubDate>Fri, 25 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/linkedlist/</guid>
         <description>

&lt;hr /&gt;

&lt;h1 id=&#34;problemas&#34;&gt;Problemas&lt;/h1&gt;

&lt;p&gt;No &lt;a class=&#34;external&#34; href=&#34;http://joaoarthurbm.github.io/eda/posts/arraylist&#34;&gt;material sobre ArrayLists&lt;/a&gt; discutimos algumas preocupações oriundas do uso de arrays e que estão todas conceitualmente relacionadas ao fato de que o array é uma estrutura de tamanho fixo. Isso impede o seu crescimento de forma dinâmica. Sempre que for preciso crescer a capacidade de um array é preciso criar um novo e transferir todos os elementos do array original para essa nova instância, o que é uma operação com tempo de execução $O(n)$.&lt;/p&gt;

&lt;p&gt;O fato do array ter tamanho fixo também implica em operações de remanejamento de elementos durante a inserção em uma posição arbitrária (&lt;strong&gt;&lt;em&gt;shiftParaADireita&lt;/em&gt;&lt;/strong&gt;) e durante a remoção de um elemento (&lt;strong&gt;&lt;em&gt;shiftParaAEsquerda&lt;/em&gt;&lt;/strong&gt;), ambas com tempo de execução $O(n)$.&lt;/p&gt;

&lt;p&gt;Por último, por definirmos de antemão o tamanho da estrutura, é possível que a quantidade de elementos no array seja menor do que a sua capacidade. Esse pode ser um problema de menor magnitude e importância atualmente porque a memória &amp;ldquo;desperdiçada&amp;rdquo; pode ser considerada irrelevante. Contudo, conceitualmente é importante discutir esse fato porque o uso indiscriminado de memória, quando cumulativo, pode gerar problemas.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;LinkedLists&lt;/em&gt;&lt;/strong&gt; podem ser vistas como contraponto à estruturas baseadas em arrays. &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; são listas dinâmicas. Ao contrário de estruturas baseadas em arrays, os objetos de uma &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; são criados e removidos sob demanda.&lt;/p&gt;

&lt;h3 id=&#34;como-isso-é-feito&#34;&gt;Como isso é feito?&lt;/h3&gt;

&lt;p&gt;Através da criação de objetos que possuem referências para seus vizinhos. Ou seja, encadeando os objetos. Daí o nome de lista encadeada.&lt;/p&gt;

&lt;h3 id=&#34;e-que-objetos-são-esses&#34;&gt;E que objetos são esses?&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Nós.&lt;/strong&gt; Criamos nós que guardam a informação que queremos manipular e referências para seus vizinhos, que são do mesmo tipo. No nosso caso, vamos guardar objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;, que possuem matrícula e nome. Contudo, para fins didáticos, na visualização vamos identificar apenas com um número inteiro. Vamos ao código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; {
    
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aluno;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }   
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Esta é uma classe auxiliar com visibilidade &lt;em&gt;default&lt;/em&gt; e criada dentro do mesmo arquivo da classe &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt;. Tomei essa decisão de projeto para evitar a manipulação verborrágica de referências através de &lt;strong&gt;&lt;em&gt;getNext()&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;setNext()&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Visualmente, objetos do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; podem ser representados da seguinte maneira:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Node exemploNode = new Node(new Aluno(8, &amp;quot;João&amp;quot;));&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;node.png&#34; alt=&#34;node&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Vamos descrever bem o que cada coisa significa. Primeiro, estamos chamando de valor o objeto do tipo aluno armazenado no &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; (representado apenas por um número inteiro). O valor pode ser um objeto de qualquer tipo, pois a lista é uma estrutura de propósito geral. Escolhemos o tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt; para fins didáticos e escolhemos representá-lo visualmente como um inteiro para simplificar nossa vida.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;exemploNode&lt;/em&gt;&lt;/strong&gt; é uma referência para um objeto do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; são referências para objetos do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt;. &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; aponta para o próximo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt;, que no nosso primeiro exemplo é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; enquanto &lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; aponta para o &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; anterior, que também é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Como cada nó tem referências para o anterior e para o próximo, chamamos essa lista de duplamente encadeada.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Como usar objetos do tipo Node para criar uma lista?&lt;/strong&gt; Em termos simplistas, ligando os nós. Veja:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
Node &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno(8, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;João&amp;#34;&lt;/span&gt;));
Node &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno(11, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Marielle&amp;#34;&lt;/span&gt;));
a.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b;
b.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a;
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;ligando.png&#34; alt=&#34;ligando&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Em primeiro lugar, criamos dois nós: &lt;strong&gt;&lt;em&gt;a&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;b&lt;/em&gt;&lt;/strong&gt;. Depois, fizemos &lt;code&gt;a.next&lt;/code&gt; apontar para o nó &lt;strong&gt;&lt;em&gt;b&lt;/em&gt;&lt;/strong&gt; (destaque em vermelho) e &lt;code&gt;b.prev&lt;/code&gt; apontar para &lt;strong&gt;&lt;em&gt;a&lt;/em&gt;&lt;/strong&gt; (destaque em verde). Com essas instruções encadeamos os objetos e temos agora uma lista com dois elementos e podemos, apenas a partir da referência do primeiro, acessar o segundo. Como? &lt;code&gt;a.next&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note que os objetos foram criados em tempo de execução. Ou seja, a lista é criada dinamicamente sem que seja preciso definir o seu tamanho em tempo de compilação.&lt;/p&gt;

&lt;p&gt;Vamos analisar a lista abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;exemplo-lista.png&#34; alt=&#34;exempli-lista&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Não precisamos guardar todas as referências para os nós criados. Nesse caso apenas guardamos uma referência para o início da lista (&lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;) e vamos encadeando os nós para formar a lista. Guardamos também uma referência para o fim da lista (&lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;) para efetuar adicionar elementos no final da lista de maneira mais eficiente, como vamos discutir adiante.&lt;/p&gt;

&lt;p&gt;Uma &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; é nada mais do que um controlador dessas referências. Vamos ver como isso se dá em código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; LinkedList {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; head;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; tail;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; size;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LinkedList&lt;/span&gt;() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; isEmpty() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
    
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;organização-interna-atributos-construtor-e-isempty&#34;&gt;Organização interna: atributos, construtor e isEmpty&lt;/h2&gt;

&lt;p&gt;Primeiro, vamos às definições de atributos e do construtor. A classe &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; possui três atributos: uma referência para o início da lista, outra para o fim e um inteiro representando a quantidade de elementos na lista. No construtor &lt;em&gt;default&lt;/em&gt; esses atributos são iniciados com &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; e 0, respectivamente. Eu sei que não é preciso fazer isso porque os valores &lt;em&gt;default&lt;/em&gt; de Java para esses tipos são os mesmos que atribuí no construtor. Contudo, eu prefiro deixar isso explícito para que fique claro para quem está aprendendo e ainda não é fluente com as particularidades da linguagem.&lt;/p&gt;

&lt;h3 id=&#34;isempty&#34;&gt;isEmpty()&lt;/h3&gt;

&lt;p&gt;Este método verifica se a lista está vazia ou não. A verificação é feita comparando &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; com &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Se essa comparação for verdadeira, significa que não elemento algum na lista, pois &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; é a referência que controla o início e a partir da qual conseguimos acessar os outros elementos.&lt;/p&gt;

&lt;h2 id=&#34;operações-básicas-inserção-busca-e-remoção&#34;&gt;Operações básicas: inserção, busca e remoção.&lt;/h2&gt;

&lt;h3 id=&#34;inserção&#34;&gt;Inserção&lt;/h3&gt;

&lt;p&gt;Vamos abordar três tipos de inserção e uma lista encadeada:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;addLast(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addFirst(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add(int index, Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;addLast(Aluno aluno).&lt;/strong&gt; O primeiro método adiciona um elemento no final da lista. Como mantemos uma referência para o final da lista, a única preocupação aqui é saber se trata-se do primeiro elemento a ser adicionado. Caso seja esse o cenário, ambos, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, passam a apontar para o novo elemento. Caso contrário, precisamos fazer o novo elemento assumir o papel de &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;. Vamos ao código:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; addLast(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(aluno);
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(isEmpty()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tail;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em um primeiro momento, criamos o nó que será adicionado. Depois, verificamos se a lista está vazia. Se estiver, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; apontam para o novo nó. Caso contrário, efetuamos 3 passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;adicionamos o novo nó à frente de &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; com a instrução
&lt;code&gt;this.tail.next = newNode&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fazemos com que o anterior do novo nó seja &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; com a instrução &lt;code&gt;newNode.prev = tail&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;o fim da lista passa a ser o novo nó &lt;code&gt;this.tail = newNode&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A adição de um elemento ao final da lista é realizada em tempo constante $O(1)$, pois envolve apenas a verificação de uma expressão booleana e algumas manipulações de referências.&lt;/p&gt;

&lt;p&gt;Note que apenas a primeira adição impacta na referência &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;. No entanto, todas as adições impactam a referência &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, pois todo novo elemento passa a ser considerado o fim da lista.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;addFirst(Aluno aluno).&lt;/strong&gt; Este método adiciona elementos no início da lista. Nesse cenário também é preciso verificar se a lista está vazia. Caso seja esse o cenário, ambos, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, passam a apontar para o novo elemento. Caso contrário, precisamos fazer o novo elemento assumir o papel de &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; addFirst(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(aluno);
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
    }
        
    size &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em um primeiro momento, criamos o nó que será adicionado. Depois, verificamos se a lista está vazia. Se estiver, &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; apontam para o novo nó. Caso contrário, efetuamos 3 passos:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;adicionamos o novo nó atrás de &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; com a instrução &lt;code&gt;newNode.next = this.head&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;fazemos com que o anterior de &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; aponte para o novo nó com a instrução &lt;code&gt;this.head.prev = newNode&lt;/code&gt;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;o início da lista passa a ser o novo nó, ou seja, &lt;code&gt;this.head = newNode&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A adição de um elemento no início da lista é realizada em tempo constante $O(1)$, pois envolve apenas a verificação de uma expressão booleana e algumas manipulações de referências.&lt;/p&gt;

&lt;p&gt;Note que apenas a primeira adição impacta na referência &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;. No entanto, todas as adições impactam a referência &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt;, pois todo novo elemento passa a ser considerado o início da lista.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;add(int index, Aluno aluno).&lt;/strong&gt; A semântica deste método é: encaixar um novo elemento no índice passado como parâmetro &amp;ldquo;afastando&amp;rdquo; os elementos à frente para a direita. O uso das aspas em afastando é para chamar atenção para o fato de que não precisamos executar a operação de &lt;strong&gt;&lt;em&gt;shift&lt;/em&gt;&lt;/strong&gt; $(O(n))$, mas apenas alterar as referências ($O(1)$).&lt;/p&gt;

&lt;p&gt;Vamos supor que o foi efetuada a chamada &lt;code&gt;lista.add(3, new Aluno(5, &amp;quot;Amarildo&amp;quot;))&lt;/code&gt;, em que queremos adicionar o objeto com matrícula 5 na posição 3 da lista. Veja a ilustração abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;insert.png&#34; alt=&#34;insert&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que o objeto com matrícula 5 vai assumir a posição 3 da lista. Para isso precisamos alterar as seguintes referências:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; do novo nó passa a ser o nó com valor 3;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; do novo nó passa a ser o nó com valor -9;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt; do nó com valor -9 passa a ser o novo nó;&lt;/li&gt;
&lt;li&gt;O &lt;strong&gt;&lt;em&gt;prev&lt;/em&gt;&lt;/strong&gt; do nó com valor 3 passa a ser o novo nó.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A essa altura você já deve ter percebido que listas encadeadas não são indexadas como as listas baseadas em arrays. Isto é, não há como acessar em tempo constante a n-ésima posição da lista, pois &lt;strong&gt;não&lt;/strong&gt; há como executar a instrução &lt;code&gt;listaEncadeada[index]&lt;/code&gt;. É preciso iterar até a posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; para adicionar o novo elemento. Lembrando que temos apenas as referências para o início e o fim da lista. Assim, precisamos partir do início da lista até uma posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; navegando através das referências &lt;strong&gt;&lt;em&gt;next&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Vamos analisar detalhadamente o código do método &lt;strong&gt;&lt;em&gt;add(int index, int value)&lt;/em&gt;&lt;/strong&gt; para discutirmos essas preocupações.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; add(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; size)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(aluno);
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addFirst&lt;/span&gt;(valor);
        
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(valor);
        
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
            aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
            
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
        newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
            
        size &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
            
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em primeiro lugar, verificamos se o índice passado como parâmetro é válido. Caso não seja, lançamos uma exceção.&lt;/p&gt;

&lt;p&gt;Caso &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; seja válido, criamos o novo nó e precisamos agora identificar 3 casos. Se o &lt;code&gt;index == 0&lt;/code&gt;, basta invocarmos o método &lt;strong&gt;&lt;em&gt;addFirst&lt;/em&gt;&lt;/strong&gt;, que já implementamos. Se &lt;code&gt;index == size&lt;/code&gt;,  basta invocarmos o método &lt;strong&gt;&lt;em&gt;addLast&lt;/em&gt;&lt;/strong&gt;, que já implementamos. Caso contrário, caímos no cenário da Figura acima. Então, precisamos iterar até a posição index - 1 e manipular as referências.&lt;/p&gt;

&lt;h3 id=&#34;como-iterar-em-uma-lista-encadeada&#34;&gt;Como iterar em uma lista encadeada?&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;           
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
    aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Inicialmente criamos uma referência auxiliar (&lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt;). Ela inicialmente aponta para &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e, a cada passo da iteração, vai sendo atribuída para o próximo da lista (&lt;code&gt;aux = aux.next&lt;/code&gt;). Não fazemos isso diretamente com a referência &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; porque perderíamos a referência para o início da lista. Por isso é preciso criar um auxiliar.&lt;/p&gt;

&lt;p&gt;Ao término desse laço, &lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt; estará apontando para o nó que será o anterior do novo nó. Vamos relembrar o cenário:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;insert-aux.png&#34; alt=&#34;insert-aux&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que &lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt; aponta para o nó com valor -9 após o loop. Apenas com uma referência para esse nó podemos então encaixar o novo nó com as instruções:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A adição de um elemento em uma posição arbitrária da &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; é $O(n)$, pois envolve iterar sobre a lista e, no pior caso, o índice passado como parâmetro é da ordem do número de elementos presentes.&lt;/p&gt;

&lt;h3 id=&#34;busca&#34;&gt;Busca&lt;/h3&gt;

&lt;p&gt;Vamos explorar 5 formas de acesso a elementos de uma LinkedList:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Aluno get(int index)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int indexOf(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean contains(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno getFirst()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno getLast()&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Os três primeiros métodos compartilham de uma aspecto importante: todos envolvem iteração sobre a lista e, por isso, são $O(n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; size)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; indexOf(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()))
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; index;
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        index &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; contains(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; indexOf(aluno) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Aluno get(int index).&lt;/strong&gt; Este método recupera o aluno presente na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;. Em primeiro lugar verificamos se a posição é válida. Caso não seja lançamos uma exceção &lt;a class=&#34;external&#34; href=&#34;https://docs.oracle.com/javase/7/docs/api/java/lang/IndexOutOfBoundsException.html&#34;&gt;
IndexOutOfBounds&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Caso o índice seja válido, precisamos iterar do início da lista até o índice desejado. Usamos o comando &lt;strong&gt;&lt;em&gt;for&lt;/em&gt;&lt;/strong&gt; por se tratar de uma iteração definida. Ao final dessa iteração &lt;strong&gt;&lt;em&gt;aux&lt;/em&gt;&lt;/strong&gt; aponta para o nó na posição &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;. Assim, retornamos &lt;code&gt;aux.aluno&lt;/code&gt;, que é o objeto desejado.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;int indexOf(Aluno aluno).&lt;/strong&gt; Este método retorna o índice da primeira ocorrência do valor passado como parâmetro na lista. Novamente, iteramos sobre a lista, mas dessa vez usamos o comando &lt;strong&gt;&lt;em&gt;while&lt;/em&gt;&lt;/strong&gt;, pois a iteração é indefinida. Note que há duas condições de parada. Quando &lt;code&gt;aux == null&lt;/code&gt;, ou seja, percorremos toda a lista e não encontramos o aluno procurado e, por isso, retornamos -1. Ou quando encontramos o aluno procurado. Nesse último caso retornamos o valor da variável &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt;, que é incrementada a cada passo da procura.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;boolean contains(Aluno aluno).&lt;/strong&gt; Este método apenas verifica se o aluno passado como parâmetro está presente na lista ou não. Para isso, reusamos o método &lt;strong&gt;&lt;em&gt;indexOf&lt;/em&gt;&lt;/strong&gt;. Se o resultado da execução for -1, o método &lt;strong&gt;&lt;em&gt;contains&lt;/em&gt;&lt;/strong&gt; retorna &lt;strong&gt;&lt;em&gt;false&lt;/em&gt;&lt;/strong&gt;. Caso contrário, retorna &lt;strong&gt;&lt;em&gt;true&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Os métodos &lt;strong&gt;&lt;em&gt;getFirst()&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;getLast()&lt;/em&gt;&lt;/strong&gt;, por sua vez, são $O(1)$, pois basta retornarmos os alunos armazenados nos nós cujas referências são &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;, respectivamente.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; getFirst() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; getLast() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;remoção&#34;&gt;Remoção&lt;/h3&gt;

&lt;p&gt;Vamos explorar 4 formas remoção em uma &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Aluno removeFirst()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno removeLast()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Aluno remove(int index)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean remove(Aluno aluno)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Os dois primeiros métodos envolvem apenas a manipulação de algumas referências e, por isso, são $O(1)$. Em ambos, precisamos checar se a lista está vazia ou se possui apenas um elemento.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; removeFirst() {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NoSuchElementException();
        
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
        
    size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; removeLast() {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; NoSuchElementException();
        
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }           
    
    size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;

}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;removeFirst().&lt;/strong&gt; Esse método remove e retorna o primeiro elemento da lista. A primeira verificação que fazermos é se a lista está vazia. Se esse for o caso, lançamos a exceção &lt;strong&gt;&lt;em&gt;NoSuchElementException&lt;/em&gt;&lt;/strong&gt;. Depois, precisamos verificar se a lista contém apenas um elemento, pois isso requer que as referências &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; passem a apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Caso nenhuma dessas condições sejam verdadeiras (&lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt;), temos pelo menos dois elementos na lista. Nesse caso, basta fazer head apontar para o próximo elemento da lista (&lt;code&gt;head = head.next&lt;/code&gt;) e &lt;code&gt;head.prev&lt;/code&gt; apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;removeLast().&lt;/strong&gt; Esse método remove e retorna o último elemento da lista. A primeira verificação que fazermos é se a lista está vazia. Se esse for o caso, lançamos a exceção &lt;strong&gt;&lt;em&gt;NoSuchElementException&lt;/em&gt;&lt;/strong&gt;. Depois, precisamos verificar se a lista contém apenas um elemento, pois isso requer que as referências &lt;strong&gt;&lt;em&gt;head&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; passem a apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Caso nenhuma dessas condições sejam verdadeiras (&lt;strong&gt;&lt;em&gt;else&lt;/em&gt;&lt;/strong&gt;), temos pelo menos dois elementos na lista. Nesse caso, basta fazer &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; apontar para o seu anterior (&lt;code&gt;tail = tail.prev&lt;/code&gt;) e &lt;code&gt;tail.next&lt;/code&gt; apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Os outros dois métodos envolvem iterar sobre a lista, seja até o índice passado como parâmetro, seja procurando pelo elemento a ser removido. Por isso, ambos são $O(n)$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; size)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; IndexOutOfBoundsException();
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; removeFirst();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; removeLast();
    
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; index; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    
    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
                   size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;       
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;;
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; remove(Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;) {
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;head&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(aluno)) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; 0) removeFirst();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1) removeLast();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
                aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;prev&lt;/span&gt;;
                size &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;
            }
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;;
        }
        aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;;
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;remove(int index) e remove(Aluno aluno).&lt;/strong&gt; Quando o elemento é encontrado, há 3 casos possíveis: o elemento está na primeira posição, na última ou entre outros dois. No primeiro caso, reusamos o método &lt;strong&gt;removeFirst()&lt;/strong&gt;. No segundo caso, reusamos o método &lt;strong&gt;removeLast()&lt;/strong&gt;. Para o terceiro caso, manipulamos as referências para ligar o anterior e o próximo: &lt;code&gt;aux.prev.next = aux.next&lt;/code&gt; e &lt;code&gt;aux.next.prev = aux.prev&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Por motivos de simplificação, a classe &lt;strong&gt;&lt;em&gt;LinkedList&lt;/em&gt;&lt;/strong&gt; que implementamos neste material manipula objetos do tipo &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; que armazenam objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;. Naturalmente, por ser de propósito geral, a implementação de &lt;a class=&#34;external&#34; href=&#34;https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html&#34;&gt;LinkedList&lt;/a&gt; de Java permite o armazenamento e manipulação de qualquer objeto.&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Tabelas Hash</title>
         <link>https://joaoarthurbm.github.io/eda/posts/hashtable/</link>
         <pubDate>Thu, 24 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/hashtable/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Quando tratamos de estrutura de dados estamos sempre interessados na eficiência de operações fundamentais de coleções, como busca, inserção e remoção. Nesse sentido, o array, embora seja uma estrutura elementar, é um excelente escolha para diversos cenários, pois nos fornece acesso, inserção e remoção em tempo $O(1)$. Isto é, se soubermos o índice em que um elemento está, o tempo de acesso a esse elemento é extremamente eficiente. O mesmo ocorre para adicionar um elemento em uma posição arbitrária, pois o custo dessa operação é dado pela operação primitiva de atribuição (ex: &lt;code&gt;array[4] = &amp;quot;computacao@ufcg&amp;quot;&lt;/code&gt;). Por fim, a remoção pode também ser efetuada em $O(1)$ atribuindo o valor da posição para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; (ex: &lt;code&gt;array[8] = null&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Vamos analisar o cenário em que desejamos armazenar objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt; que representam os alunos de Computação @ UFCG. Para fins de simplificação, o objeto do tipo aluno possui dois atributos: matrícula e nome.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; Aluno {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; matricula;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; nome;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; getMatricula() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;matricula&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;String&lt;/span&gt; getNome() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;nome&lt;/span&gt;;
    }
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Vamos também assumir que a matrícula identifica unicamente um aluno do curso e que é um inteiro no domínio [0&amp;hellip;1999]&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;. Nesse material chamamos de chaves os atributos dessa natureza. Dentro desse cenário, um array é uma estrutura muito adequada, porque podemos armazenar o aluno na posição do array cujo valor é o mesmo de sua matrícula. Não somente a inserção, mas a busca e a remoção desse objeto pode ser realizada em tempo $O(1)$, pois &lt;strong&gt;há uma correspondência direta entre o identificador único do aluno (a chave) e o índice em que ele se encontra no array&lt;/strong&gt;. Veja:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(String[] &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;) {
    Aluno[] &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno[2000];

    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;joao&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno(21, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;João Arthur&amp;#34;&lt;/span&gt;);

    &lt;span style=&#34;color:#75715e&#34;&gt;// inserindo em tempo constante
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    alunos[joao.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; joao;

    &lt;span style=&#34;color:#75715e&#34;&gt;// buscando em tempo constante
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos[joao.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()] &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        ...

    &lt;span style=&#34;color:#75715e&#34;&gt;// removendo em tempo constante
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    alunos[joao.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;()] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note que, como há uma correspondência direta entre a matrícula e o índice em que o elemento está, as operações são muito eficientes.&lt;/p&gt;

&lt;p&gt;Chamamos de &lt;strong&gt;Tabela de Acesso Direto&lt;/strong&gt; o array que é usado dessa maneira, isto é, com os valores sendo mapeados de forma direta para os índices do array. Foi assim que usamos o array para ordenar em tempo linear com o &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/ordenacao-linear/&#34;&gt; Counting Sort&lt;/a&gt;, lembra?&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;os-problemas&#34;&gt;Os Problemas&lt;/h1&gt;

&lt;p&gt;Vamos tentar ser um pouco mais realistas no nosso exemplo. Todos sabemos que as matrículas em Computação @ UFCG não variam de 0 a 1999, certo? Nossas matrículas são números inteiros de 9 dígitos (ex: 203198353). Portanto, teoricamente, [000000000, 999999999] é o intervalo de matrículas válidas em Computação @ UFCG. Normalmente, em outros domínios isso também é verdade. Os elementos que nos identificam unicamente são tipicamente números com vários dígitos, por exemplo, CPF, cartão de crédito, identidade etc. Assim, se quiséssemos armazenar os alunos utilizando a matrícula como índices teríamos que criar um array com $10^9$ posições.&lt;/p&gt;

&lt;p&gt;Mesmo isso sendo possível, uma grande parte desse array não seria utilizada, pois o padrão usado para criar as matrículas baseia-se no ano, período de entrada e posição de entrada no vestibular e, por isso, exclui uma grande quantidade de números no intervalo [000000000, 999999999]. Além disso, ao longo de toda a história, Computação @ UFCG teve aproximadamente 2000 matrículas, o que significa que o número de matrículas efetivamente usadas é bem menor do que o número de matrículas possíveis. Isto é, teríamos que criar um array de $10^9$ posições para usar aproximadamente apenas os primeiros 2000 índices.&lt;/p&gt;

&lt;p&gt;Importante destacar também que para outros cenários, como por exemplo o CPF que possui 11 dígitos, não somente o desperdício de memória é um problema, mas não há como criar arrays de $10^11$ posições em várias linguagens de programação.&lt;/p&gt;

&lt;p&gt;Em resumo, é inviável utilizar mapeamento direto (tabela de acesso direto) para chaves cujo valor é muito alto. Além disso, não é eficiente do ponto de vista de memória utilizar mapeamento direto em domínios cujo conjunto de chaves efetivamente utilizado é bem menor do que o conjunto de chaves possível.&lt;/p&gt;

&lt;p&gt;Por último, mas não menos importante, nem sempre a chave é representada como um inteiro. Por exemplo, para fins de identificação, a Polícia Federal utiliza uma chave com 3 caracteres e 5 números inteiros (ex: CVP3018). Não é difícil notar que não há índice CVP3018 em um array, certo?&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-solução-tabela-hash&#34;&gt;A Solução: Tabela Hash&lt;/h1&gt;

&lt;p&gt;Vamos deixar claro: queremos mapear valores inteiros grandes (ex: 87562874658) para índices de um array. Veja a figura abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;exemplo1.png&#34; alt=&#34;tabela1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para isso, vamos utilizar uma função matemática. A ideia é criar essa função de mapeamento &lt;strong&gt;&lt;em&gt;(hash(chave)&lt;/em&gt;&lt;/strong&gt;) entre o valor da chave e um inteiro (hash) que seja um índice válido no array. A essa função damos o nome de função hash. Usando essa função conseguimos mapear as chaves para os índices do array e conseguimos então armazenar nossos objetos. Os objetos, nesse caso, são chamados de valores. Assim, na tabela armazenamos os pares &lt;strong&gt;&lt;em&gt;&lt;chave, valor&gt;&lt;/em&gt;&lt;/strong&gt;. Como a chave é tipicamente um atributo do objeto, essa redundância é bem comum. Isto é, armazenamos a chave e o objeto, que por sua vez contém a chave.&lt;/p&gt;

&lt;p&gt;Note que a função de hash precisa ter algumas características bem importantes:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A função &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt; deve ser determinística. Para uma determinada chave a função sempre retorna o mesmo valor dehash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Por ser utilizada como uma função de indexação, a função de hash deve sempre retornar um valor de hash dentro dos limites da tabela $[0, N-1]$, onde $N$ é o tamanho da tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uniforme. Todos os índices do array devem ter aproximadamente a mesma chance de serem mapeados pela função dehash. Essa característica é importante para distribuir os elementos uniformemente pela tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A função de hash deve ser executada em tempo constante $O(1)$.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;como&#34;&gt;Como?&lt;/h2&gt;

&lt;p&gt;A gente já fez isso nesse documento. Conceitualmente, na tabela de acesso direto apresentada na contextualização temos a seguinte função de hash:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; hash(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; chave;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ou seja, o hash de uma chave é o valor dela própria. Essa é uma função de hash bem simples, mas adequada para diversos contextos. Contudo, isso nos causou problemas para para grandes valores chave e para cenários em que o número de chaves efetivamente usado for bem menor que o número de chaves possível, lembra?&lt;/p&gt;

&lt;p&gt;Uma alternativa para uma função de hash seria utilizar a operação matemática módulo. Vejamos:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; hash(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; chave &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; tabela.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Veja que essa é a solução que foi utilizada na Figura acima. Pois, $807365841 % 10 = 1$, $111983749 % 10 = 9$ e $665422653 % 10 = 3$.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Por que módulo?&lt;/strong&gt; Primeiro porque sempre vai gerar um inteiro dentro do intervalo de índices válidos do array. Segundo porque para uma mesma chave, a função sempre retorna o mesmo hash.&lt;/p&gt;

&lt;p&gt;Note que, se a função de hash for executada em tempo constante, o que é o caso da função $chave % tabela.length$, temos que as funções básicas da tabela hash são, em princípio, também executadas em tempo constante.&lt;/p&gt;

&lt;p&gt;Vamos analisar o código abaixo que apresenta algumas operações básicas da classe &lt;strong&gt;&lt;em&gt;TabelaHash&lt;/em&gt;&lt;/strong&gt;. Por motivos de simplificação, a classe que usaremos aqui implementa uma tabela hash para manipular objetos do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt;. Naturalmente, por ser de propósito geral, as implementações de Java de uma Tabela Hash (HashMap e HashTable) permitem o armazenamento e manipulação de qualquer objeto.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; HashTable {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt;[] tabela;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HashTable&lt;/span&gt;() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Aluno[20];
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; hash(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; chave &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    }  

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; put(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;valor&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; valor;
    }  

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
        Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash(chave)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
    }  

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Parece tudo resolvido, não é? Mas&amp;hellip;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; &lt;b&gt;E se duas chaves distintas forem mapeadas para a mesma posição na tabela? &lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Por exemplo, vimos que o objeto $(807365841, &amp;ldquo;Chico Buarque&amp;rdquo;)$ foi mapeado para o índice 1 da tabela porque $807365841 % 10$ é igual a 1. Suponha que agora temos que armazenar o objeto $(478243081, &amp;ldquo;Gilberto Gil&amp;rdquo;)$. Teremos um problema aqui, pois o hash desse objeto também tem valor 1, cujo índice já está ocupado. Na verdade, toda chave que terminar com o dígito 1 será mapeada para a posição 1 na tabela. Esse problema se chama &lt;strong&gt;colisão&lt;/strong&gt;. Quando estamos diante desse problema, temos três caminhos a seguir:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Aplicar a técnica do avestruz, isto é, enfiar a cabeça na terra e fingir que o problema não existe;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Melhorar nossa função de hash para que a mesma não mapeie diferentes chaves para a mesma posição;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Lidar com a colisão.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;O caminho de número 1 está fora de cogitação porque não queremos que uma estrutura de dados sobrescreva inadvertidamente um elemento que colocamos nela anteriormente.&lt;/p&gt;

&lt;p&gt;O caminho número 2 é válido e discutiremos mais adiante algumas decisões de projeto de funções de hash que reduzem o número de colisões. Contudo, a menos que a função seja perfeita, o que é muito raro, veremos também que, mesmo tomando essas decisões, colisões são inevitáveis.&lt;/p&gt;

&lt;p&gt;Então, nos sobra, por enquanto, o caminho 3. Vamos assumir como verdade que, mesmo se a função de hash for muito boa, é impossível evitar colisões. Portanto, haverá colisões e teremos que tratá-las de forma eficiente.&lt;/p&gt;

&lt;h2 id=&#34;resolução-de-colisões&#34;&gt;Resolução de Colisões&lt;/h2&gt;

&lt;p&gt;Há duas grandes estratégias lidar com esse problema: resolução de colisões por encadeamento e resolução de colisões por endereçamento aberto.&lt;/p&gt;

&lt;h3 id=&#34;resolução-de-colisões-por-encadeamento&#34;&gt;Resolução de colisões por encadeamento.&lt;/h3&gt;

&lt;p&gt;Por trás desse nome complicado há uma ideia bem simples. Ao invés de armazenarmos um objeto em uma posição da tabela, passamos a armazenar uma lista de objetos. Essa lista será composta de todos os objetos cujos hashes são iguais. Veja na figura abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;encadeamento.png&#34; alt=&#34;encadeamento&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Os objetos de mesmo hash foram encadeados em uma lista. Esse foi o caso de $(807365841, &amp;ldquo;Chico Buarque&amp;rdquo;)$ e $(478243081, &amp;ldquo;Gilberto Gil&amp;rdquo;)$, que estão em uma lista no índice 1 da tabela, pois os hashes de suas respectivas chaves são o mesmo: 1. O mesmo acontece com $(665422653, &amp;ldquo;Marielle&amp;rdquo;)$ e $(960424613, &amp;ldquo;Amarildo&amp;rdquo;)$, que foram encadeados em uma lista no índice 3.&lt;/p&gt;

&lt;p&gt;Importante aqui destacar que esses objetos não possuem a mesma chave, mas sim o mesmo hash. &lt;strong&gt;Não há elementos com a mesma chave em uma tabela hash&lt;/strong&gt;. Eu vou repetir em destaque porque esse é um erro recorrente:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt; &lt;b&gt;Não há elementos com a mesma chave em uma tabela hash.&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Se for realizada a tentativa de adição de um elemento cuja chave já está presente na tabela, o valor (objeto armazenado) deve ser atualizado. Também é importante destacar que devemos guardar a chave junto com o objeto na lista, pois só assim saberemos diferenciar os objetos de mesmo hash.&lt;/p&gt;

&lt;p&gt;Uma vez que estamos utilizando listas na tabela, o código das operações básicas deve ser modificado, concorda? Vamos primeiro analisar o método &lt;strong&gt;&lt;em&gt;get&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; get(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
    ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;aluno&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; alunos) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aluno.&lt;span style=&#34;color:#a6e22e&#34;&gt;matricula&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aluno;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Na segunda linha do método recuperamos a lista &lt;strong&gt;&lt;em&gt;alunos&lt;/em&gt;&lt;/strong&gt; presente no índice &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt;. Se essa lista for &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;, significa que não há elemento naquela posição da tabela e, por isso, retornamos &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; (linhas 3 e 4).&lt;/p&gt;

&lt;p&gt;Se a lista não for &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;, precisamos iterar sobre a mesma comparando as chaves (matrículas). Caso haja um objeto aluno com uma matrícula igual a passada como parâmetro, retornamos esse objeto.&lt;/p&gt;

&lt;p&gt;Se ao fim da iteração não encontrarmos nenhum objeto na lista cuja matrícula seja igual a chave passada como parâmetro, retornamos &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Vamos agora analisar o método put.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; put(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;valor&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
    ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        alunos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
        alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(valor);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; alunos;

    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt;(); i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;get&lt;/span&gt;(i).&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave) {
                alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;set&lt;/span&gt;(i, valor);
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
            }
        }
    
        alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;add&lt;/span&gt;(valor);
    }    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No início, recuperamos a lista que está no índice &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt;. Se não existir uma lista nesse índice (&lt;code&gt;alunos == null&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;criamos essa lista;&lt;/li&gt;
&lt;li&gt;adicionamos o valor nela;&lt;/li&gt;
&lt;li&gt;adicionamos a lista na tabela.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Se existir uma lista nesse índice:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;iteramos sobre a lista para ver se há na mesma um elemento com a mesma chave;

&lt;ul&gt;
&lt;li&gt;se houver, atualiza-se o valor (&lt;code&gt;alunos.set(i, valor)&lt;/code&gt;);&lt;/li&gt;
&lt;li&gt;se não houver, adiciona-se o novo elemento no final da lista.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por fim, vamos analisar o método remove.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Aluno&lt;/span&gt; remove(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; hash(chave);
    ArrayList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;alunos&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;[hash];
    
    Iterator&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Aluno&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;it&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; alunos.&lt;span style=&#34;color:#a6e22e&#34;&gt;iterator&lt;/span&gt;();
    Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;atual&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (it.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasNext&lt;/span&gt;()) {
        atual &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; it.&lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;();
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (atual.&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave) {
            it.&lt;span style=&#34;color:#a6e22e&#34;&gt;remove&lt;/span&gt;();
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; atual;
        }
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; atual;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A ideia consiste em: i) recuperar a lista presente no índice &lt;strong&gt;&lt;em&gt;hash(chave)&lt;/em&gt;&lt;/strong&gt; que, a princípio, contém o elemento a ser removido e ii) iterar sobre a lista comparando a chave dos elementos (matrícula) com a chave passada como parâmetro. Caso o elemento seja encontrado, o removemos da lista.&lt;/p&gt;

&lt;h4 id=&#34;discussão-sobre-o-tempo-de-execução&#34;&gt;Discussão sobre o tempo de execução&lt;/h4&gt;

&lt;p&gt;Como foi possível perceber, a implementação dessas operações básicas inclui agora a iteração sobre as listas presentes na tabela. Isso significa que haverá um impacto na eficiência desses algoritmos, concorda? Na tabela de acesso direto as operações eram executadas em tempo constante $O(1)$. Contudo, como as listas podem crescer substancialmente e os algoritmos envolvem iteração sobre as mesmas, não temos mais esse cenário. Para exemplificar, vamos pensar no pior caso possível. Suponha que queremos adicionar os seguintes alunos na tabela:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(736435217, &amp;ldquo;Lívia&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(879995247, &amp;ldquo;Will&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(524109227, &amp;ldquo;Clara&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(736435217, &amp;ldquo;Talita&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Nesse caso, como nossa função de hash mapeia todos os elementos para o índice 7, teríamos a seguinte configuração:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;colisao.png&#34; alt=&#34;colisao.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Note que a busca por um elemento presente na tabela não seria mais realizada em tempo constante, pois envolve a iteração na lista que contém todos os elementos. Portanto, no pior caso, as operações teriam custo de execução $O(n)$, o que queremos evitar ao máximo.&lt;/p&gt;

&lt;p&gt;Naturalmente, não queremos que o pior caso seja frequente e, por isso, escolhemos funções de hash que &amp;ldquo;espalham&amp;rdquo; os elementos pela tabela para que as listas não possuam muitos elementos. Portanto, o desempenho médio das operações na tabela hash depende do tamanho médio das listas armazenadas. Lembra da propriedade de uma função de hash que estabelece que todos os índices do array devem ter aproximadamente a mesma chance de serem mapeados pela função de hash. Essa característica é importante para distribuir os elementos uniformemente pela tabela e faz com que as listas tenham tamanho médio semelhante. Então, para uma tabela de tamanho $m$ que armazena nelementos, esperamos que o tamanho médio das listas seja $\alpha = n/m$. A esta medida damos o nome de fator de carga.&lt;/p&gt;

&lt;p&gt;A análise depende então do tempo de execução da função de hash e do tamanho médio das listas. Como vimos, escolhemos funções de hash que executam em $O(1)$.Então, o tempo de execução das operações básicas pode ser dado por:&lt;/p&gt;

&lt;p&gt;$T(n) = 1 + \alpha$, onde $\alpha$ é o tamanho médio das listas armazenadas na tabela.&lt;/p&gt;

&lt;h3 id=&#34;resolução-de-colisões-por-endereçamento-aberto&#34;&gt;Resolução de colisões por endereçamento aberto.&lt;/h3&gt;

&lt;p&gt;Essa estratégia não utiliza listas para lidar com colisões. A ideia é procurar um outro índice livre da tabela para armazenar o elemento quando houver colisão. Há diversas estratégias para procurar esse índice. Vamos apresentar a mais simples delas: procurar o próximo. Veja a implementação do método &lt;strong&gt;&lt;em&gt;put(chave, Aluno)&lt;/em&gt;&lt;/strong&gt; quando adotamos essa estratégia:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; put(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chave&lt;/span&gt;, Aluno &lt;span style=&#34;color:#a6e22e&#34;&gt;valor&lt;/span&gt;) {       
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sondagem&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 0;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hash&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (sondagem &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; tabela.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;) {
        
        hash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (hash(chave) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; sondagem) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; tabela.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (tabela[hash] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
            tabela[hash].&lt;span style=&#34;color:#a6e22e&#34;&gt;getMatricula&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; chave &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
            tabela[hash].&lt;span style=&#34;color:#a6e22e&#34;&gt;equals&lt;/span&gt;(APAGADO)) {
                tabela[hash] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; valor;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
            
        sondagem &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; TabelaCheiaException();

}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O importante aqui é entender o uso da variável sondagem. Ela inicia com valor zero e é utilizada como fator para calcular o hash. Caso haja colisão, essa variável é incrementada e a próxima posição na tabela será analisada. Isso é feito até que uma das condições abaixo seja satisfeita:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;encontrar um índice livre. Um índice está livre quando seu conteúdo é null ou quando seu conteúdo é um objeto APAGADO (explicação mais adiante);&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;encontrar um valor cuja chave é igual a passada como parâmetro. Nesse caso, atualiza-se o valor;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;não encontrar posição livre na tabela (&lt;code&gt;sondagem == tabela.length - 1&lt;/code&gt;).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note que não há listas e, portanto, nenhum elemento é armazenado fora da tabela. Isso significa que o fator de carga ($\alpha$) nunca pode ser maior do que 1. Por isso lançamos a exceção ao final da execução do método caso não haja posição livre na tabela. Tomamos essa decisão para fins didáticos. Na prática, quando a tabela atinge um certo nível de ocupação, executamos o método resize, isto é, cria-se uma outra tabela maior e transfere-se os elementos da tabela anterior para a nova aplicando a nova função de hash (ver &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;rehash&lt;/em&gt;&lt;/strong&gt;).&lt;/p&gt;

&lt;p&gt;Para entender bem a ideia de sondagem, vamos analisar a adição dos seguintes objetos na tabela:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(736435217, &amp;ldquo;Lívia&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(879995247, &amp;ldquo;Will&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(524109227, &amp;ldquo;Clara&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;(736435217, &amp;ldquo;Talita&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;colisao-prob.png&#34; alt=&#34;colisao-prob&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Na primeira adição, o objeto $(736435217, &amp;ldquo;Lívia&amp;rdquo;)$ ocupa a posição 7 na tabela, pois esse índice é calculado da seguinte maneira:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((736435217 % 10) + 0) % 10;&lt;/p&gt;

&lt;p&gt;Ou seja, o hash assume valor 7. Explicando: como o valor inicial da sondagem é zero, temos que $7 + 0 = 7$. Calculamos então o resto da divisão desse valor pelo tamanho da tabela $7 % 10 = 7$. Portanto, o índice avaliado é o índice 7. Por não haver nenhum elemento nesse índice, o objeto é adicionado.&lt;/p&gt;

&lt;p&gt;Na segunda adição, isto é, na adição do objeto $(879995247, &amp;ldquo;Will&amp;rdquo;)$, o objeto ocupará a posição 8 da tabela. Isso acontece porque o cálculo&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((879995247 % 10) + 0) % 10;&lt;/p&gt;
            

&lt;p&gt;também tem como resultado o índice 7. Então temos uma colisão nesse índice. O algoritmo então incrementa o valor da sondagem para 1. Assim, temos um novo cálculo,&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((879995247 % 10) + 1) % 10; &lt;/p&gt;

&lt;p&gt;que resulta em 8. Como 8 é um índice não ocupado, adicionamos o valor nesse índice.&lt;/p&gt;

&lt;p&gt;Na terceira adição, temos duas colisões: usando $sondagem = 0$ e $sondagem = 1$. Somente quando usamos $sondagem = 2$ é que encontramos um índice livre.&lt;/p&gt;

&lt;p&gt;Na quarta adição, temos três colisões: usando $sondagem = 0$, $sondagem = 1$ e $sondagem = 2$. Somente quando usamos $sondagem = 3$ é que encontramos um índice livre. Note que esse objeto será adicionado no índice 0 da tabela, pois o resultado da expressão abaixo é 0.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash = ((736435217 % 10) + 3) % 10;&lt;/p&gt;

&lt;p&gt;Como estamos incrementando a sondagem sempre em uma unidade para avaliar o próximo índice da tabela, chamamos essa técnica de sondagem linear. Outras estratégias de sondagem também são utilizadas, como por exemplo, a sondagem quadrática em que, ao invés de incrementar a sondagem em uma unidade, usamos uma função quadrática para esse incremento.&lt;/p&gt;

&lt;p&gt;O método &lt;strong&gt;&lt;em&gt;get&lt;/em&gt;&lt;/strong&gt; e o método &lt;strong&gt;&lt;em&gt;remove&lt;/em&gt;&lt;/strong&gt; também precisam usar a sondagem, pois as colisões também afetam a busca e a remoção. Em particular, é preciso ter um cuidado a mais com o método remove. Quando vamos remover um elemento de uma tabela, não atribuímos &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; no índice como fazíamos até então.&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;&lt;b&gt;Por que?&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;Porque na adição e na busca a sondagem precisa diferenciar se o conteúdo do índice é de fato &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou se ele já foi ocupado antes por algum elemento que foi apagado. Por isso, quando apagamos um elemento, ao invés da instrução &lt;code&gt;tabela[hash] = null&lt;/code&gt;, incluímos uma guarda naquele índice para estabelecer que ele está vago para uma nova adição. Isso é feito incluindo um objeto &amp;ldquo;flag&amp;rdquo;. No nosso caso, escolhemos um objeto do tipo &lt;strong&gt;&lt;em&gt;Aluno&lt;/em&gt;&lt;/strong&gt; com matrícula &lt;strong&gt;&lt;em&gt;Integer.MIN_VALUE&lt;/em&gt;&lt;/strong&gt; e nome &amp;ldquo;APAGADO&amp;rdquo;. Veja a implementação dessa estratégia no &lt;a class=&#34;external&#34; href=&#34;código disponível no github&#34;&gt;código disponível no github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Assim, na adição, se o conteúdo do índice for &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou for APAGADO, o índice está livre para ser preenchido.&lt;/p&gt;

&lt;p&gt;Na busca, se o conteúdo do índice for APAGADO a sondagem deve continuar a procura, ao invés de parar. Por isso precisamos dessa flag.&lt;/p&gt;

&lt;p&gt;Em resumo, ao apagar um objeto, ao invés de atribuir &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ao índice, incluímos uma objeto flag APAGADO para que os algoritmos de sondagem possam saber quando de fato parar.&lt;/p&gt;

&lt;h4 id=&#34;discussão-sobre-o-tempo-de-execução-1&#34;&gt;Discussão sobre o tempo de execução&lt;/h4&gt;

&lt;p&gt;Novamente, a implementação das operações básicas incluem iteração. Na resolução por encadeamento essa iteração era realizada nas listas. Na resolução por endereçamento aberto essa iteração é dentro da própria tabela, seguindo a sondagem estabelecida. No caso em que todas as chaves possuem o mesmo hash, o tempo de execução será $O(n)$, onde $n$ é a quantidade de elementos na tabela. Naturalmente, esse é o pior caso e é gerado porque nossa função de hash não lida muito bem com chaves que terminam com o mesmo dígito. Portanto, chegou a hora de discutirmos melhores estratégias para cálculo do hash.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;funções-de-hash&#34;&gt;Funções de Hash&lt;/h1&gt;

&lt;p&gt;A função de hash que estamos utilizando até então sempre usava apenas o último dígito do número como hash, uma vez que estávamos tratando de uma tabela de tamanho 10. Você consegue enxergar isso? O resto da divisão de qualquer número por 10 é o último dígito desse número.&lt;/p&gt;

&lt;p&gt;Essa não é uma função de hash boa. Tivemos a oportunidade de ver isso com detalhes para os casos em que vários elementos de chaves diferentes foram mapeados para a mesma posição porque o último dígito de cada uma dessas chaves era igual ao último dígito das demais chaves.&lt;/p&gt;

&lt;p&gt;E se usarmos um número primo na divisão? Uma boa estratégia é escolher um número primo para ser o tamanho da tabela. Vamos ver como essa pode ser uma boa estratégia na prática.&lt;/p&gt;

&lt;p&gt;Suponha o seguinte conjunto de chaves $K = {200, 205, 210, 215, 220, 225&amp;hellip;595}$. Se escolhermos uma tabela de tamanho 100, teríamos a função de hash definida por $hash(chave) = chave % 100$. Para esse conjunto de chaves apenas os índices terminados em 0 e 5 seriam mapeados pela função de hash. Isto é, as posições 0, 5, 10, 15, 20, 15 e assim por diante. Em cada uma dessas posições teríamos 4 colisões. Por exemplo, na posição 0, teríamos os objetos de chaves 200, 300, 400 e 500 mapeados. Na posição 5, teríamos os objetos de chaves 205, 305, 405 e 505 mapeados. Na posição 10, teríamos os objetos 210, 310, 410 e 510 mapeados, e assim por diante. Além do desperdício de memória, temos um número elevado de colisões. 60, para ser exato.&lt;/p&gt;

&lt;p&gt;Agora vamos escolher uma tabela de tamanho 101, um número primo. Nossa função de hash passa a ser definida por $hash(chave) = chave % 101$. Para o mesmo conjunto de chaves &lt;strong&gt;não teríamos colisão alguma!&lt;/strong&gt; Basta fazer a operação em cada chave para verificar que todas as chaves desse conjunto seriam mapeadas para índices diferentes na tabela.&lt;/p&gt;

&lt;p&gt;O &lt;strong&gt;método da multiplicação&lt;/strong&gt; é uma outra estratégia para desenvolver uma boa função de hash. Ao invés de dividirmos a chave por um número primo, como fazemos no método da divisão, aplicamos as seguintes operações:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;multiplicar a chave por uma constante &amp;ndash; um número decimal;&lt;/li&gt;
&lt;li&gt;extrair a parte fracioária do resultado anterior;&lt;/li&gt;
&lt;li&gt;multiplicar o número anterior pelo tamanho da tabela;&lt;/li&gt;
&lt;li&gt;extrair a parte inteira do resultado anterior.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A função de hash é definida, então, por:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;hash(chave) = int(((chave * A) % 1) * m),&lt;/p&gt;

&lt;p&gt;onde $A$ é um número constante decimal e $m$ é o tamanho da tabela.&lt;/p&gt;

&lt;p&gt;Vamos analisar exemplo concreto. Suponha que a chave seja 100, o número decimal escolhido seja $A = 0.63274838$ e o tamanho da tabela seja 20.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;100*0.63274838 = 63.274838&lt;/li&gt;
&lt;li&gt;63.274838 % 1 = 0.274838&lt;/li&gt;
&lt;li&gt;0.274838 * 20 = 5.49676&lt;/li&gt;
&lt;li&gt;int(5.49676) = 5&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Teríamos então que hash(100) = 5.&lt;/p&gt;

&lt;h2 id=&#34;rehash-e-resize&#34;&gt;Rehash e Resize&lt;/h2&gt;

&lt;p&gt;O método da divisão por um número primo e o método da multiplicação são estratégias eficazes para reduzir a probabilidade de colisão. Esses dois métodos aliados à resolução por encadeamento ou por endereçamento aberto tornam a tabela hash uma estrutura de dados eficiente, pois permitem que as operações básicas de inserção, remoção e busca sejam executadas em tempo constante. Todavia, mesmo com essas estratégias, se quisermos armazenar na tabela um número de objetos maior do a sua capacidade teremos problemas em ambas. Na resolução por encadeamento teremos listas cada vez maiores e, por consequência, degradação na eficiência das operações. Na resolução por endereçamento aberto não é possível um fator de carga maior do que 1, isto é, não é possível armazenar na tabela um número de objetos maior do que o tamanho da mesma. Portanto, temos que aumentar o tamanho da tabela (&lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt;) quando o número de elementos a serem armazenados se aproxima do seu tamanho. Concretamente, quando a expressão booleana abaixo for avaliada como &lt;strong&gt;&lt;em&gt;true&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;size&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tabela&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;fatorDeCarga&lt;/span&gt;) {
    resize()
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Como sabemos, a tabela é um array e, por isso, não é possível aumentar o seu tamanho inicial. O que fazemos é criar uma nova tabela maior do que a original e realocar os elementos nessa nova tabela. Aqui é importante destacar que os elementos não são alocados nas posições originais, pois, ao criar uma nova tabela, teremos também uma nova função de hash, dado que o tamanho da tabela mudou e nossa função baseia-se nesse tamanho para o cálculo do hash (&lt;strong&gt;&lt;em&gt;rehash&lt;/em&gt;&lt;/strong&gt;). Nesse caso, temos que iterar sobre todos os elementos da tabela original invocando o método put em todos esses elementos. &lt;a class=&#34;external&#34; href=&#34;https://github.com/joaoarthurbm/eda-ufcg/tree/master/java/src/tabelahash&#34;&gt;O código disponibilizado no github&lt;/a&gt; implementa essa rotina.&lt;/p&gt;

&lt;p&gt;Como vamos iterar sobre os elementos da tabela, esse é um bom momento para que você conheça os métodos: &lt;strong&gt;&lt;em&gt;keySet()&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;values()&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;entrySet()&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;keySet()&lt;/em&gt;&lt;/strong&gt; retorna o conjunto de chaves presentes na tabela. No nosso caso seria o conjunto de todas as matrículas armazenadas na tabela.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;value()&lt;/em&gt;&lt;/strong&gt; retorna o conjunto de valores presentes na tabela. No nosso caso seria o conjunto de todos os alunos armazenados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;entrySet()&lt;/em&gt;&lt;/strong&gt; retorna o conjunto de itens (chave, valor) presentes na tabela. No nosso caso seria o conjunto de pares Matrícula, Aluno armazenados na tabela.&lt;/p&gt;

&lt;p&gt;Note que independente do método utilizado é importante destacar que não há a noção de ordenação em uma tabela hash, isto é, o elemento no índice 3 da tabela não necessariamente foi adicionado antes do elemento no índice 4.&lt;/p&gt;

&lt;h3 id=&#34;quando-executar-o-resize&#34;&gt;Quando executar o resize?&lt;/h3&gt;

&lt;p&gt;Uma tabela hash que resolve colisões por endereçamento aberto possui um fator de carga menor do que 1. Vamos relembrar: fator de carga é a ocupação máxima permitida em uma tabela. Se a tabela possui $m$ posições, podemos, por exemplo, estabelecer que a ocupação máxima é 50% (0.5). Assim, quando atingirmos esse limite, o resize é executado. Então, surge a pergunta:&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;Qual fator de carga máximo utilizar? Isto é, quando executar o resize?&lt;/p&gt;

&lt;p&gt;Se utilizarmos um fator de carga muito pequeno, faríamos o &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; com muita frequência, o que queremos evitar por se tratar de uma rotina $O(n)$.Contudo, se o fator de carga for alto, digamos 0.95 o número de colisões aumenta bastante e degrada a eficiência das operações.
A biblioteca padrão de Java utiliza 0.75 como fator de carga. Esse número foi estabelecido porque, através de experimentos, notou-se que a partir desse fator de carga as colisões passam a ser muito mais frequentes e o desempenho das operações piora substancialmente.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;resumo&#34;&gt;Resumo&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Chave identifica unicamente um objeto. Tipicamente é um atributo dele. Por exemplo, matrícula para aluno, CPF para pessoa, CNPJ para empresa, número do cartão de crédito para cliente etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uma tabela de acesso direto é um array em que os objetos são indexados pelas suas respectivas chaves. Por isso ela só é adequada para chaves inteiras e com valores pequenos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Hash é um valor inteiro gerado a partir da chave. Usamos esse hash quando temos que lidar com chaves inteiras de valor muito grande ou que não são números naturais.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tabela hash é um nome sofisticado para um array cuja indexação é feita através de uma função.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tabela hash é uma estrutura de dados eficiente no que diz respeito à inserção, remoção e busca de elementos.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O método da divisão por um número primo e o método da multiplicação são boas estratégias para implementar funções de hash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Uma função de hash deve ser determinística, executada em tempo constante e uniforme.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Não há elementos com a mesma chave em uma tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Diferentes chaves podem ter o mesmo hash. Isso se chama colisão.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Exceto em algumas raras exceções, colisões vão existir. A forma como lidamos com elas é encadeando objetos em uma lista ou procurando outras posições livres na tabela.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A biblioteca padrão de Java utiliza endereçamento aberto para lidar com colisões.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Quando o número de objetos a serem armazenados cresce a ponto de degradar a eficiência das operações básicas, precisamos criar uma nova tabela e realocar todos os elementos da tabela original nessa nova tabela. Isso se chama resize. Quando fazemos isso, aplicamos a nova função de hash. Isso se chama rehash.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A biblioteca padrão de Java usa 0.75 como fator de carga para decidir quando fazer o resize. Isso significa que quando a tabela atinge 75% de ocupação o resize é executado.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;A implementação utilizada neste material foi baseada em chaves inteiras e valores do tipo Aluno. Essa foi uma decisão didática. Uma Tabela Hash é uma estrutura de dados de propósito geral e deve ser capaz de armazenar objetos de qualquer tipo.&lt;/p&gt;

&lt;p&gt;Utilizei neste capítulo chaves baseadas em números inteiros também para fins didáticos. Chaves podem ser de qualquer tipo. O importante é que elas identifiquem unicamente um objeto.&lt;/p&gt;

&lt;p&gt;Este é um material carece de algumas discussões importantes que conduzo em sala de aula. Em particular, acho relevante discutir: Por que um número primo é uma boa escolha no método da divisão? Por que um número decimal com muitos dígitos depois da vírgula é uma boa escolha no método da multiplicação? Quais são os problemas relacionados à sondagem linear? Quais são as outras formas de sondagem e seus respectivos problemas?&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;O número de alunos em toda a história de Computação @ UFCG até a escrita desse material não passava de 2000.
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:1&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Uma aula só com perguntas: Endereçamento Aberto</title>
         <link>https://joaoarthurbm.github.io/eda/posts/enderecamento-aberto-so-perguntas/</link>
         <pubDate>Wed, 23 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/enderecamento-aberto-so-perguntas/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Neste artigo vou descrever um experimento que fiz em sala de aula. Tentei lecionar Resolução de Colisões em Tabelas Hash utilizando apenas perguntas para a turma.&lt;/p&gt;

&lt;p&gt;Eu estou no meu segundo ano como professor da UFCG e já me cansei de usar slides em sala de aula. Não que eu queira fazer uma cruzada contra os slides. Sei que eles funcionam para vários cenários. Contudo, eu acho que, no contexto das minhas disciplinas, eles mais atrapalham do que ajudam.&lt;/p&gt;

&lt;p&gt;Corta para a RE-03.&lt;/p&gt;

&lt;p&gt;Dito isso, na aulas de Estrutura de Dados e Algoritmos, tenho tentado outras alternativas para conduzir as discussões. Desde o semestre passado, por exemplo, utilizo uma variação de DOJO para a implementação dos algoritmos clássicos de ordenação. Em linhas gerais, funciona desta maneira: divido a turma em grupos pequenos e os faço pensar na solução para o problema proposto. Um a um, os grupos são chamados para implementar a solução no meu computador, cuja tela está projetada para a sala. Cada grupo possui apenas 2min para contribuir com a solução. Naturalmente, cada grupo deve continuar a implementação a partir do ponto em que o outro grupo parou. Assim, a solução é construída por N (n &amp;gt; 2) mãos. Para melhorar a discussão e entendimento do assunto, ao final dos 2 minutos, peço para cada grupo explicar o que fez e o que falta para terminar a solução.&lt;/p&gt;

&lt;p&gt;Essa primeira experiência foi bem proveitosa para o aprendizado. Contudo, assim como a aula com slides, não é viável aplicá-la sempre. Por isso, e pelo cansaço com slides, procurei outras formas de conduzir minhas aulas. Há um tempo atrás, li um artigo de um professor que conduziu uma aula inteira de programação apenas fazendo perguntas (alguém, por favor, me ajuda a achar esse artigo). O ócio me fez pensar: por que não replicar em Estrutura de Dados? Pois bem, a partir de agora, relato o que aconteceu hoje na RE-03.&lt;/p&gt;

&lt;h2 id=&#34;preparação&#34;&gt;Preparação&lt;/h2&gt;

&lt;p&gt;Inicialmente, avisei para os alunos que o meu objetivo era fazer apenas perguntas na sala de aula e perguntei se eles topariam o desafio. Como eu não deixei escolha, todos toparam. :)&lt;/p&gt;

&lt;p&gt;Para ser sincero, não me preparei muito para a aula. Eu sabia o que queria passar, mas tinha receio que, se preparasse as questões de antemão, a aula sairia tão mecanizada quanto o passar de slides. Assim, eu fui para a sala de aula com tópicos a serem cobertos:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;resolução de colisões com endereçamento aberto&lt;/li&gt;
&lt;li&gt;probing linear e quadrático&lt;/li&gt;
&lt;li&gt;fator de carga&lt;/li&gt;
&lt;li&gt;rehash&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Assunto da aula:&lt;/strong&gt; &lt;em&gt;Resolução de colisões em tabelas hash utilizando endereçamento aberto.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-aula&#34;&gt;A aula&lt;/h2&gt;

&lt;p&gt;A partir de agora, vai ser em forma de diálogo e observações, ok? Vamos lá.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;- O que vimos na aula passada?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Resolução de colisões usando chainning.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Como funciona?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Os alunos explicaram o funcionamento.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Qual a complexidade da busca ?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Muitos responderam $O(1)$. Aqui houve o primeiro desvio do que tinha em mente. O ideal seria que a resposta fosse $O(1+alpha)$, onde $alpha$ é o tamanho médio das listas. Caso a turma tivesse respondido assim, a aula continuaria como planejada. Contudo, tive que desenhar um exemplo de colisões na tabela que gerou uma lista razoavelmente grande e, para reforçar que as operações não são $O(1)$ e sim $O(1 + alpha)$, fiz a seguinte pergunta:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— O(1) mesmo?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nesse momento eles refletiram e responderam corretamente. Com o mesmo exemplo, eu perguntei:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E se não pudéssemos utilizar listas? E se em cada slot só coubesse um par &lt;key,value&gt;?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Silêncio. Aqui foi mais um momento em que tive que improvisar.&lt;/p&gt;

&lt;p&gt;*&lt;strong&gt;— Vamos lá. Houve colisões. Há espaço para alocar esse novo objeto?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Sim.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Onde?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Pode ser na próxima posição livre.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Como? Se minha função de hash me joga para aquela posição.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nesse momento houve hesitação da turma. Meu objetivo aqui era que eles sacassem que adicionando +1 no resultado do hash seria uma forma. Assim, voltei para a função de hash e perguntei:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E se eu colocasse hash(x) = (x % n) + 1, funcionaria?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Sim.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E se eu adicionar um elemento que caiu nessa mesma posição?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Usa hash(x) = (x%n) + 2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E se eu adicionar mais um elemento que caiu nessa mesma posição?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Usa hash(x) = (x%n) + 3.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Ótimo! Então como posso generalizar essa minha função?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mais hesitação. Nesse momento tive que transformar uma afirmação em pergunta:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E se eu colocasse um i ao invés dessas constantes? O i começaria de quanto?&lt;/em&gt;&lt;/strong&gt;
— 0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E iria aumentando como?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— De um em um.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Qual o nome bonito para isso?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Linearmente.&lt;/p&gt;

&lt;p&gt;Aqui tive que introduzir o nome do conceito (linear probing). Aí não teve jeito.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Ok, pessoal. Vocês acabaram de resolver colisões usando endereçamento aberto com probing linear.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Contudo, quando se usa endereçamento aberto, os algoritmos de &lt;strong&gt;&lt;em&gt;put&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;get&lt;/em&gt;&lt;/strong&gt; devem ser modificados em relação à estratégia de chainning. Por isso, perguntei:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Como ficaria o algoritmo de busca em uma tabela com essa estratégia?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A turma ficou calada novamente. Insisti:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Vamos lá. Se eu pesquisar pela chave X, qual o protocolo?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Calcula o hash dela.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Como sempre?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Não. Começa com zero no lugar de i.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Ok. E agora?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Compara a chave com a que está na tabela.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E se não for a que eu estou procurando?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Aumenta o i para 1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E se ainda não for a que eu estou procurando?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Aumenta o i para 2.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Vou fazer isso até quando? Como fica o algoritmo? Que comando em programação utilizar?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— while. Enquanto não for igual, aumento o probing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Só isso? E quando o elemento realmente não estiver na tabela?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nesse momento a turma não soube responder. Acabei afirmando que as outras condições do while deveriam ser &lt;code&gt;!= null&lt;/code&gt; e &amp;ldquo;não inspecionei toda a tabela&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Usei o mesmo raciocínio para os algoritmos de &lt;strong&gt;&lt;em&gt;put&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;remove&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Até aqui estava bem contente com o andamento da aula. Minha estratégia de apenas fazer perguntas estava funcionando e eu vinha vencendo os objetivos da aula um a um, tal como Rafaela Silva.&lt;/p&gt;

&lt;p&gt;Mas aí, precisei explicar o conceito de Probing Quadrático. Para isso, fiz uma relação com com exponential &lt;em&gt;backoff&lt;/em&gt;. Expliquei um pouco, fugindo da ideia original de utilizar só perguntas. No entanto, ainda sim, fiz perguntas como:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— O que faço para acentuar a distância entre esses dois números?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A resposta eu já havia dado antes. Elevar ao quadrado é uma das alternativas. Assim, mostrei que o probing quadrático é melhor que o linear porque evita, com maior eficácia, clusters na tabela.&lt;/p&gt;

&lt;p&gt;Depois disso, meu objetivo era abordar rehash. Iniciei perguntando:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Estamos resolvendo colisões. Mas isso é suficiente sempre? Quando a coisa começa a degringolar?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Quando há muitos elementos na tabela.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Quem nos diz se há muitos elementos na tabela?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— O alpha.&lt;/p&gt;

&lt;p&gt;Massa. Voltei para o jogo de perguntas de novo. Desenhei uma tabela e a preenchi toda. Assim, o problema tornou-se físico. Não haveria mais espaço para o próximo elemento na tabela. Perguntei:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— E agora?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Cria outra tabela.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— De que tamanho?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— O dobro do original.&lt;/p&gt;

&lt;p&gt;Criei a tabela e perguntei:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Basta colocar os elementos em sua posição inicial?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A turma ficou calada.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— O que vou ter que mudar?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— A função de hash. Precisa dividir pelo novo tamanho da tabela.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Se eu não fizesse isso. O que aconteceria?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Os elementos da tabela anterior cairiam na mesma posição.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Certo. Então eu vou precisar recalcular o hash de todo mundo, certo?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Sim.&lt;/p&gt;

&lt;p&gt;Nesse momento, calculei para 2 elementos e um deles não caiu na posição em que estava na tabela anterior. Para fixar bem esse cenário, perguntei:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— O que aconteceu com essa chave?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Caiu em uma outra posição.&lt;/p&gt;

&lt;p&gt;Nesse momento usei a afirmação: precisamos fazer isso para cada elemento da tabela.
Só faltava deixar claro quando realizar o rehash. Assim, perguntei:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Pessoal, quando eu devo fazer rehash?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Quando a tabela estiver cheia.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— De novo. Quem me diz isso?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— O alpha.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Certo. Preciso esperar ele chegar até 1?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Não.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— Até quanto então?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— 75%.
&lt;strong&gt;&lt;em&gt;— Por que?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Não está nem muito cheio, nem muito vazio.&lt;/p&gt;

&lt;p&gt;Nesse momento discuti um pouco sobre o 75%. O mais importante foram as perguntas:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— O que acontece se eu fizer rehash com um alpha pequeno?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Vai fazer vários. Isso custa caro.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;— O que acontece se eu fizer rehash com um alpha alto?&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;— Tende a ter muitas colisões e o desempenho fica ruim.&lt;/p&gt;

&lt;p&gt;A partir daqui fiquei satisfeito com o que discutimos. Discuti apenas alguns detalhes de implementação mostrando que diferentes formas de resolver colisões podem ser vistas como estratégias e que, por isso, podemos utilizar o padrão Strategy para implementá-las.&lt;/p&gt;

&lt;h2 id=&#34;conclusão&#34;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;A aula foi muito dinâmica. Não senti falta dos slides. Farei de novo. Acho que me obriga a pensar como o aluno, ao invés de preparar um discurso e descarregá-lo.&lt;/p&gt;

&lt;h2 id=&#34;importante&#34;&gt;Importante!&lt;/h2&gt;

&lt;p&gt;Esse relato é enviesado pela minha percepção da aula. As perguntas e respostas certamente não foram exatamente como descritas aqui, pois, como não gravei, não me lembro exatamente de cada momento. No mais, esse relato é público e meus alunos podem ajudá-los a me desmascarar caso eu tenha mentido :)&lt;/p&gt;
</description>
       </item>
       
       <item>
         <title>Árvores Binárias de Pesquisa</title>
         <link>https://joaoarthurbm.github.io/eda/posts/bst/</link>
         <pubDate>Wed, 23 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/bst/</guid>
         <description>

&lt;hr /&gt;

&lt;h1 id=&#34;definições-e-propriedades&#34;&gt;Definições e Propriedades&lt;/h1&gt;

&lt;p&gt;Árvores binárias são estruturas de dados fundamentais no contexto de Ciência da Computação. Em particular, Árvores Binárias de Pesquisa são aplicadas na solução de diversos problemas que demandam eficiência em operações básicas, como busca. Informalmente, uma Árvore Binária de Pesquisa (BST)&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Outras-denomina&#34;&gt;&lt;a href=&#34;#fn:Outras-denomina&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; é uma estrutura de dados de árvore binária baseada em nós, onde a subárvore à esquerda de cada nó possui valores numéricos inferiores ao nó e a subárvore à direita de cada nó possui valores numéricos superiores ao nó. Formalmente, uma
BST é definida recursivamente da seguinte forma:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;$A$ é uma árvore nula;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;$A$ é uma tripla $(Esq, raiz, Dir)$, onde &lt;strong&gt;&lt;em&gt;Esq&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;Dir&lt;/em&gt;&lt;/strong&gt; são árvores binárias de pesquisa e &lt;strong&gt;&lt;em&gt;Esq&lt;/em&gt;&lt;/strong&gt; contém apenas valores menores do que o armazenado na raiz, enquanto &lt;strong&gt;&lt;em&gt;Dir&lt;/em&gt;&lt;/strong&gt; contém apenas valores maiores do que o armazenado na raiz.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A Figura abaixo&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:As-figuras-desse&#34;&gt;&lt;a href=&#34;#fn:As-figuras-desse&#34;&gt;2&lt;/a&gt;&lt;/sup&gt; ilustra uma árvore com raiz 63.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst1.png&#34; alt=&#34;bst1&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;o-nó&#34;&gt;O nó&lt;/h2&gt;

&lt;p&gt;Árvores são baseadas em nós. Do ponto de vista de código, temos:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; {
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
    
    Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
    }
    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Em primeiro lugar, um nó pode armazenar qualquer objeto como valor. Neste material estamos utilizando um valor inteiro para simplificar.&lt;/p&gt;

&lt;p&gt;Depois, as referências &lt;strong&gt;&lt;em&gt;left&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt; são muito parecidas com as referências de um &lt;strong&gt;&lt;em&gt;Node&lt;/em&gt;&lt;/strong&gt; em &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/linkedlist/&#34;&gt;Listas Duplamente Encadeadas&lt;/a&gt;, lembra? A única diferença aqui é que garantimos por construção que o nó para o qual a referência &lt;strong&gt;&lt;em&gt;left&lt;/em&gt;&lt;/strong&gt; aponta é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou  armazena um &lt;strong&gt;valor menor&lt;/strong&gt; do que &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt;, enquanto o nó para o qual a referência &lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt; aponta é &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt; ou armazena um &lt;strong&gt;valor maior&lt;/strong&gt; do que &lt;strong&gt;&lt;em&gt;value&lt;/em&gt;&lt;/strong&gt;. Essa restrição deve ser verdadeira para todo e qualquer nó da árvore.&lt;/p&gt;

&lt;p&gt;Formalmente uma árvore é um grafo que não contém ciclos. Todavia, na prática, nós acrescentamos a referência &lt;strong&gt;&lt;em&gt;parent&lt;/em&gt;&lt;/strong&gt; que liga um nó ao seu pai. Ou seja, na prática não estamos falando de árvore, pois há um ciclo entre cada nó e seu pai. Nós vamos conviver com esse conflito porque essa referência facilita muito caminhar árvore acima, o que é preciso em alguns algoritmos.&lt;/p&gt;

&lt;h2 id=&#34;raiz&#34;&gt;Raiz&lt;/h2&gt;

&lt;p&gt;Raiz é um nó especial da árvore. Através dele conseguimos acessar qualquer nó. Assim como mantemos uma referência para a o início de uma lista encadeada para poder acessar o restante dos elementos, na BST mantemos a referência para a raiz da árvore. A raiz da árvore ilustrada pela figura acima é 63.&lt;/p&gt;

&lt;h2 id=&#34;grau-de-um-nó&#34;&gt;Grau de um nó&lt;/h2&gt;

&lt;p&gt;O grau de um nó é a quantidade de filhos que ele possui. Naturalmente, só temos três graus possíveis em uma árvore binária de pesquisa: 0, 1 e 2. Os nós com grau zero são chamados de folhas. Na figura acima, as folhas são os nós 2, 52, 60, 65 e 83. Os nós com graus 1 e 2 são chamados de nós internos.&lt;/p&gt;

&lt;h2 id=&#34;altura&#34;&gt;Altura&lt;/h2&gt;

&lt;p&gt;A altura de uma árvore binária de pesquisa é o maior caminho entre a raiz e todas as folhas. Vamos analisar novamente a nossa árvore exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst1.png&#34; alt=&#34;bst1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para determinarmos a altura, precisamos calcular o tamanho dos caminhos entre a raiz e todas as folhas. Vamos lá:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;63 -&amp;gt; 7 -&amp;gt; 2. Tamanho do caminho = 2.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 7 -&amp;gt; 59 -&amp;gt; 52. Tamanho do caminho = 3.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 7 -&amp;gt; 59 -&amp;gt; 60. Tamanho do caminho = 3.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 69 -&amp;gt; 65. Tamanho do caminho = 2.&lt;/li&gt;
&lt;li&gt;63 -&amp;gt; 69 -&amp;gt; 90 -&amp;gt; 83. Tamanho do caminho = 3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Como dito anteriormente, a altura da árvore é o maior caminho, ou seja, h=3.&lt;/p&gt;

&lt;p&gt;A altura de uma árvore com apenas um nó é 0, enquanto a altura de uma árvore nula é -1.&lt;/p&gt;

&lt;p&gt;Esse conceito é importante pois várias operações básicas, como inserção, busca e remoção em uma BST são, do ponto de vista assintótico, $O(h)$. Portanto, idealmente, é preciso manter $h$ com o menor valor possível para que as operações sejam eficientes. No entanto, isso nem sempre é possível. Uma combinação de inserções e remoções pode levar a árvore a um estado em que a altura da sub-árvore à direita pode ser muito maior que a altura da sub-árvore à esquerda (e vice-versa). Quando a árvore atinge esse estado, dizemos que ela está desbalanceada. De maneira geral, uma árvore balanceada é aquela que a altura é $O(\log n)$.&lt;/p&gt;

&lt;h2 id=&#34;árvore-completa&#34;&gt;Árvore Completa&lt;/h2&gt;

&lt;p&gt;Uma árvore completa é aquela que todos os nós, exceto folhas, possuem grau 2 e as folhas estão no mesmo nível. Veja o exemplo abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst-completa.png&#34; alt=&#34;bst-completa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Importante aqui notar que a árvore contém 15 nós e altura 3. De maneira geral, não é difícil perceber que o número máximo de nós em uma árvore binária de altura $h$ é $2^{h+1} - 1$.&lt;/p&gt;

&lt;p&gt;Também é importante destacar que uma árvore completa possui a menor altura possível para a sua quantidade de nós. Essa altura é $h = \log (n+1)-1$, ou seja, $O(\log n)$. Isso faz com que os principais algoritmos sejamO(log n), pois são dependentes da altura.&lt;/p&gt;

&lt;h2 id=&#34;sucessor&#34;&gt;Sucessor&lt;/h2&gt;

&lt;p&gt;O sucessor de um elemento na árvore é o menor valor maior do que ele. Complicado? Imagine se pudéssemos imprimir a sequência dos valores presentes na árvore de forma ordenada. O sucessor de um elemento, seria o elemento imediatamente à frente. Por exemplo, o sucessor de 41 na árvore acima é 45. O sucessor de 15 é 20. O sucessor de 72 é 91. Naturalmente, o maior valor armazenado na árvore (99) não tem sucessor.&lt;/p&gt;

&lt;h2 id=&#34;predecessor&#34;&gt;Predecessor&lt;/h2&gt;

&lt;p&gt;O predecessor de um elemento na árvore é o maior valor menor do que ele. Complicado? Imagine se pudéssemos imprimir a sequência dos valores presentes na árvore de forma ordenada. O predecessor de um elemento, seria o elemento imediatamente antes na sequência. Por exemplo, o predecessor de 41 na árvore acima é 32. O predecessor de 15 é 11. O predecessor de 72 é 65. Naturalmente, o menor valor armazenado na árvore (1) não tem predecessor.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;implementação&#34;&gt;Implementação&lt;/h1&gt;

&lt;p&gt;Assim como &lt;a class=&#34;external&#34; href=&#34;http://joaoarthurbm.github.io/eda/posts/linkedlist&#34;&gt;LinkedList&lt;a/&gt;, a classe &lt;strong&gt;&lt;em&gt;BST&lt;/em&gt;&lt;/strong&gt; é nada mais do que um controlador das referências para os nós, mantendo apenas a referência para a raiz da árvore. Vamos ver como isso é feito em Java:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; BST {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; root;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; isEmpty() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
    ...
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; {
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
    
    Node(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v;
    }
    
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;operações-básicas-e-outros-algoritmos&#34;&gt;Operações Básicas e outros algoritmos&lt;/h2&gt;

&lt;h3 id=&#34;inserção&#34;&gt;Inserção&lt;/h3&gt;

&lt;p&gt;Primeiro, vamos ilustrar como se adiciona elementos em uma árvore binária de pesquisa. Somente depois nos preocupamos com o código, ok?&lt;/p&gt;

&lt;p&gt;Suponha que os seguintes elementos devem ser adicionados em uma árvore binária de pesquisa nessa ordem: 41, 65, 20, 19 e 50. Inicialmente temos a árvore vazia. Nesse caso, 41 assume o papel da raiz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;insercao-bst.png&#34; alt=&#34;insercao-bst&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Depois disso, 65 é adicionado à direita de 41, pois é um valor maior. 20 é adicionado à esquerda de 41, por ser menor do que esse valor. Depois 19 é comparado com 41, por ser menor, a adição deve ser feita à esquerda. Contudo, já há o elemento 20 à esquerda. Então compara-se 19 com 20. Como 19 é menor e não há nenhum nó à esquerda de 20, 19 assume essa posição. A última adição é a do valor 50. Inicialmente é comparado com a raiz e a inserção deve ser feita à direita. Então compara-se 50 com 65. Por ser menor e não haver nó à esquerda de 65, 50 assume essa posição.&lt;/p&gt;

&lt;p&gt;Note que todo novo nó é adicionado como folha na árvore.&lt;/p&gt;

&lt;p&gt;Podemos implementar a adição de maneira iterativa e recursiva. Vamos analisar primeiro a adição iterativa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; add(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty())
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
                
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { 
                    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
                    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
                    newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
                }
                    
                aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
            } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { 
                    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;newNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
                    aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; newNode;
                    newNode.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
                }
                    
                aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
            }
        }
    }
        
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A primeira verificação é feita para saber se a árvore é vazia. Se sim, basta fazermos a raiz apontar para o novo nó &lt;code&gt;this.root = new Node(element)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Caso não seja a primeira adição precisamos seguir o passo a passo ilustrado anteriormente. Ou seja, caminhar árvore abaixo fazendo a comparação do elemento adicionado com os nós no caminho. Se o elemento for menor, caminhamos para a esquerda (&lt;code&gt;aux = aux.left&lt;/code&gt;). Se for maior, caminhamos para a direita (&lt;code&gt;aux = aux.right&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;A adição é feita quando &lt;code&gt;aux.left == null&lt;/code&gt;, se o elemento for menor ou &lt;code&gt;aux.right == null&lt;/code&gt;, se o elemento for maior. Note que o trecho liga não somente o pai ao novo nó, mas também liga o novo nó ao pai (&lt;code&gt;newNode.parent = aux&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Agora vamos nos debruçar sobre a implementação recursiva.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; recursiveAdd(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty())
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        recursiveAdd(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;, element);
    }
        
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; recursiveAdd(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
            node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        recursiveAdd(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;, element);
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
            node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Node(element);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        }
        recursiveAdd(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;, element);
    }
        
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Usamos dois métodos para implementar a recursão. O primeiro, público, tem a assinatura padrão que recebe o valor a ser adicionado. Esse método verifica se a árvore é nula e, se for, faz com que a referência &lt;strong&gt;&lt;em&gt;root&lt;/em&gt;&lt;/strong&gt; aponte para o novo nó (&lt;code&gt;this.root = new Node(element)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;O outro método também recebe como parâmetro o elemento adicionado, além de receber o nó atualmente sendo analisado. Inicialmente o primeiro nó passado é a raiz.&lt;/p&gt;

&lt;p&gt;As verificações e condições de parada são as mesmas da versão iterativa:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;se o elemento é menor e a esquerda é nula, adiciona-se o elemento à esquerda do nó atual. Se o elemento é menor e a esquerda não é nula, chama-se recursivamente o método add passando como parâmetro o nó à esquerda;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;se o elemento é maior e a direita é nula, adiciona-se o elemento à direita do nó atual. Se o elemento é maior e a direita não é nula, chama-se recursivamente o método add passando como parâmetro o nó à direita.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Em ambas as estratégias o novo elemento é adicionado como folha. Portanto, no pior caso, a adição tem tempo de execução dado por $O(h)$, pois $h$ é o maior caminho entre a raiz e todas as folhas.&lt;/p&gt;

&lt;h3 id=&#34;busca&#34;&gt;Busca&lt;/h3&gt;

&lt;p&gt;A busca em uma árvore binária de pesquisa também usa as propriedades de ordenação dos nós para decidir que caminho percorrer. Compara-se o elemento com a raiz. Se for maior, a busca deve seguir pela sub-árvore à direita (&lt;code&gt;aux = aux.right&lt;/code&gt;). Caso contrário, deve seguir pela sub-árvore à esquerda (&lt;code&gt;aux = aux.left&lt;/code&gt;). Esse mesmo processo é feito com a raiz dessas sub-árvores. O algoritmo pára se o elemento for encontrado (&lt;code&gt;aux.value == element&lt;/code&gt;) ou se alcançar uma folha e não encontrar o elemento (&lt;code&gt;aux == null&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Veja abaixo a versão iterativa da busca binária.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; search(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {   
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; element) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
    }
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;

}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A versão recursiva da busca binária também utiliza dois métodos. O método público seguindo a assinatura padrão e um privado auxiliar para controlar a recursão.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; recursiveSearch(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; recursiveSearch(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;, element);
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; recursiveSearch(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; node;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; recursiveSearch(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;, element);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; recursiveSearch(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;, element);
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A ideia é a mesma. Compara-se o elemento com o nó atual. Se for menor, há uma chamada recursiva para a sub-árvore à esquerda (&lt;strong&gt;&lt;em&gt;recursiveSearch(node.left, element)&lt;/em&gt;&lt;/strong&gt;). Se for menor, há uma chamada recursiva para a direita (&lt;strong&gt;&lt;em&gt;recursiveSearch(node.right, element)&lt;/em&gt;&lt;/strong&gt;). O algoritmo pára o nó sob análise for nulo.&lt;/p&gt;

&lt;p&gt;A busca binária tem seu tempo de execução dependente da altura da árvore, pois no pior caso o algoritmo percorre um ramo da árvore até o final e esse ramo tem altura $h$. Assim, a busca binária é $O(h)$.&lt;/p&gt;

&lt;h3 id=&#34;mínimo-e-máximo&#34;&gt;Mínimo e Máximo&lt;/h3&gt;

&lt;p&gt;Mínimo é o menor valor presente na árvore, enquanto máximo é o maior. Para encontrar o mínimo, basta caminharmos na árvore para a esquerda até que não haja mais nós. O último nó visitado é o mínimo. De maneira análoga, o máximo é o último elemento mais à direita na árvore. Abaixo estão as implementações desses métodos. O mínimo é implementado de maneira recursiva, enquanto o máximo de maneira iterativa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; min() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}
    
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; min(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; node;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; max() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        
    Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;      

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; node;

}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;sucessor-1&#34;&gt;Sucessor&lt;/h3&gt;

&lt;p&gt;Se um nó possui sub-árvore à direita, o seu sucessor é o mínimo dessa sub-árvore. Vamos a um exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst-completa.png&#34; alt=&#34;bst-completa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Qual é o sucessor de 20? Se há sub-árvore à direita, basta retornamos o mínimo dessa sub-árvore. Ou seja, 27.&lt;/p&gt;

&lt;p&gt;E se não houver sub-árvore à direita? Por exemplo, qual é o sucessor de 55? Como não há sub-árvore à direita, precisamos subir na árvore até encontrar um elemento maior do que 55. Primeiro comparamos com 50. Como 50 é menor, subimos para 65. Encontramos o sucessor de 55, pois é o primeiro elemento árvore acima maior do que ele.&lt;/p&gt;

&lt;p&gt;Você não precisa decorar isso, certo? Faz todo sentido procurar pelo mínimo da sub-árvore à direita, pois é lá que estão os valores maiores que o nó. O mínimo deles é o sucessor. E se não houver sub-árvore à direita, é natural que o sucessor esteja árvore acima, pois à esquerda todos os valores são menores. Então o algoritmo verifica árvore acima o primeiro elemento maior que o nó sob análise.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; sucessor(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
            aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O método recebe o nó para o qual deseja se encontrar o sucessor. Se esse nó for nulo, o método retorna nulo. Caso contrário, verifica-se se há sub-árvore à direita (&lt;code&gt;node.right != null&lt;/code&gt;). Se houver, retorna-se o mínimo dessa sub-árvore.&lt;/p&gt;

&lt;p&gt;Caso não haja sub-árvore à direita, caminhamos árvore acima (&lt;code&gt;aux = aux.parent&lt;/code&gt;) até encontrarmos um elemento maior ou subirmos toda a árvore e não encontrarmos (&lt;code&gt;aux == null&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;predecessor-1&#34;&gt;Predecessor&lt;/h3&gt;

&lt;p&gt;A identificação do predecessor é muito semelhante ao sucessor.
Se um nó possui sub-árvore à esquerda, o seu predecessor é o máximo dessa sub-árvore. Vamos a um exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;bst-completa.png&#34; alt=&#34;bst-completa&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Qual é o predecessor de 20? Se há sub-árvore à esquerda, basta retornamos o máximo dessa sub-árvore. Ou seja, 15.&lt;/p&gt;

&lt;p&gt;E se não houver sub-árvore à esquerda? Por exemplo, qual é o predecessor de 27? Como não há sub-árvore à esquerda, precisamos subir na árvore até encontrar um elemento menor do que 27. Primeiro comparamos com 29. Como 29 é maior, subimos para 20. Encontramos o predecessor de 27, pois é o primeiro elemento árvore acima menor do que ele.&lt;/p&gt;

&lt;p&gt;Você não precisa decorar isso, certo? Faz todo sentido procurar pelo máximo da sub-árvore à esquerda, pois é lá que estão os valores menores que o nó. O máximo deles é o predecessor. E se não houver sub-árvore à esquerda, é natural que o predecessor esteja árvore acima, pois à direita todos os valores são maiores. Então o algoritmo verifica árvore acima o primeiro elemento menor que o nó sob análise.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt; predecessor(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (aux &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
            aux &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; aux;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;altura-1&#34;&gt;Altura&lt;/h3&gt;

&lt;p&gt;Como dito anteriormente, a altura é o maior caminho entre a raiz e todas as folhas.
A implementação é bem simples. Basta somar 1 cada vez que um novo nó é visitado e calcular
de maneira recursiva o máximo entre a altura da sub-árvore à esquerda e da sub-árvore à direita. Lembrando que a altura de uma árvore cuja raiz é nula é -1.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; height() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; height(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; height(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(node &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 1 &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(height(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;), height(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;));
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;remoção&#34;&gt;Remoção&lt;/h3&gt;

&lt;p&gt;A remoção em uma árvore binária de pesquisa possui três casos a serem analisados.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Caso 1: O nó a ser removido é uma folha.&lt;/strong&gt; Nesse caso, basta fazermos com que o pai do nó, se existir, passe a apontar a sua direita ou a esquerda para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;. Precisamos também verificar se o nó removido é raiz. Se for, simplesmente fazemos a raiz apontar para &lt;strong&gt;&lt;em&gt;null&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;isLeaf&lt;/span&gt;()) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Caso 2: O nó a ser removido possui apenas um filho.&lt;/strong&gt; Se o nó possuir apenas um filho, precisamos ligar esse filho ao pai do nó a ser removido. Naturalmente, precisamos diferenciar se o único filho é à esquerda ou à direita. Além disso, precisamos verificar se o nó removido é a raiz da árvore.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasOnlyLeftChild&lt;/span&gt;()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;)  {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;;
        }
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;hasOnlyRightChild&lt;/span&gt;()) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;)
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;parent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;;
        }
            
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Caso 3: O nó a ser removido possui dois filhos.&lt;/strong&gt; Nesse caso, trocamos o nó com o seu sucessor e chamamos recursivamente o método remove passando o nó sucessor.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
} &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        Node &lt;span style=&#34;color:#a6e22e&#34;&gt;sucessor&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sucessor(toRemove);
        toRemove.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sucessor.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;;
        remove(sucessor);
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;percorrendo-árvores-binárias&#34;&gt;Percorrendo Árvores Binárias&lt;/h2&gt;

&lt;p&gt;De maneira geral, há duas estratégias para percorrer um grafo: em profundidade (&lt;em&gt;depth-first search&lt;/em&gt;) e em largura (&lt;em&gt;breadth-first search&lt;/em&gt;). Essas estratégias são utilizadas em diversos algoritmos fundamentais em Ciência da Computação. Por exemplo, o algoritmo de Dijkstra, que calcula o menor caminho entre qualquer par de vértices em um grafo, segue a estratégia em profundidade. A busca em largura é também bastante utilizada para análise de mapas. Por exemplo, se um grafo representa o mapa onde os vértices são as cidades e as arestas o caminho entre elas, podemos utilizar busca em largura para determinar o número de cidades no caminho entre duas delas.&lt;/p&gt;

&lt;p&gt;Ambas as estratégias têm como objetivo percorrer o grafo. O que as difere é a decisão de qual nó visitar primeiro quando houver mais de uma possibilidade. Trocando em miúdos, a diferença é a ordem de visitação dos nós.&lt;/p&gt;

&lt;h3 id=&#34;em-profundidade&#34;&gt;Em Profundidade&lt;/h3&gt;

&lt;p&gt;A ideia é escolher um nó de partida e explorar todo o ramo da árvore antes de voltar e visitar os outros ramos. Vamos adotar essa estratégia para percorrer a árvore abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O mantra é: para cada nó visitado explore o máximo à esquerda deste nó e depois o máximo à direita.&lt;/p&gt;

&lt;p&gt;Inicialmente escolhemos como ponto de partida a raiz. No nosso caso, visitar significa que vamos imprimir o nó, ok? Então o primeiro nó impresso é 52.&lt;/p&gt;

&lt;p&gt;Depois disso, vamos explorar o ramo o máximo à esquerda. Então decidimos ir para 22. Novamente, explorando o máximo à esquerda, o próximo nó a ser visitado é o 8. Até aqui temos a seguinte impressão: 52 -&amp;gt; 22 -&amp;gt; 8.&lt;/p&gt;

&lt;p&gt;Neste ponto já exploramos o máximo da esquerda de 8, agora vamos para a direita. Então imprimimos o valor 11. Até aqui temos: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11.&lt;/p&gt;

&lt;p&gt;Como não há mais direita nem esquerda a ser explorada de 8, subimos para 22. A esquerda de 22 já foi toda explorada, então vamos para a direita. Visitamos 43. Lembre-se, &lt;strong&gt;para cada nó&lt;/strong&gt; eu tenho que visitar toda a esquerda e depois a direita. Então vamos para a esquerda de 43, que é 26. O resultado parcial até aqui é: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11 -&amp;gt; 43 -&amp;gt; 26.&lt;/p&gt;

&lt;p&gt;Voltamos para 52 e exploramos a direita, isto é 85. Imprimimos 85 e vamos o máximo para a esquerda.  O resultado parcial é então: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11 -&amp;gt; 43 -&amp;gt; 26 -&amp;gt; 85 -&amp;gt; 81 -&amp;gt; 69.&lt;/p&gt;

&lt;p&gt;Exploramos toda a esquerda de 69. Agora vamos para a direita. 74. Depois subimos e vamos para a direita de 81, que não existe e, por isso, não imprimimos nada. Por fim subimos até 85 e visitamos a sua direita (96).&lt;/p&gt;

&lt;p&gt;O resultado final desse percurso em profundidade é: 52 -&amp;gt; 22 -&amp;gt; 8 -&amp;gt; 11 -&amp;gt; 43 -&amp;gt; 26 -&amp;gt; 85 -&amp;gt; 81 -&amp;gt; 69 -&amp;gt; 74 -&amp;gt; 96.&lt;/p&gt;

&lt;p&gt;Essa é uma das estratégias de percorrer uma árvore em profundidade. Lembra que escolhemos explorar o nó, sua esquerda e depois a sua direita? Essa escolha tem um nome particular &lt;strong&gt;percurso em pré-ordem&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; preOrder() {
    preOrder(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; preOrder(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;);
        preOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
        preOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Há outras duas escolhas clássicas: em-ordem e pós-ordem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Em-ordem: esquerda, nó, direita.&lt;/strong&gt; Neste tipo de percurso em profundidade, primeiro visitamos toda a esquerda de um nó, depois visitamos o nó e só depois a sua direita. Retomando nosso exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para a árvore acima, temos como resultado o seguinte percurso: 8 -&amp;gt; 11 -&amp;gt; 22 -&amp;gt; 26 -&amp;gt; 43 -&amp;gt; 52 -&amp;gt; 69 -&amp;gt; 74 -&amp;gt; 81 -&amp;gt; 85 -&amp;gt; 96. Note que o resultado do caminho em-ordem em uma árvore binária de pesquisa é sempre uma sequência ordenada.&lt;/p&gt;

&lt;p&gt;Como isso foi feito? Aplicando o mantra &amp;ldquo;esquerda, nó, direita&amp;rdquo; para cada nó visitado. Inicialmente escolhemos a raíz. Note que só vamos imprimir a raiz depois de visitar todos os nós à sua esquerda. Isso é verdade para cada nó visitado. Por isso, caminhamos o máximo à esquerda e o primeiro elemento a ser impresso é 8. Depois disso 11, 22, 26, 43&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; inOrder() {
    inOrder(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; inOrder(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        inOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;);
        inOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Pós-ordem: esquerda, direita, nó.&lt;/strong&gt; Neste tipo de percurso em profundidade, primeiro visitamos toda a esquerda de um nó, depois visitamos toda a direita e só depois visitamos o nó. Retomando nosso exemplo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para a árvore acima, temos como resultado o seguinte percurso: 11 -&amp;gt; 8 -&amp;gt; 26 -&amp;gt; 43 -&amp;gt; 22 -&amp;gt; 74 -&amp;gt; 69 -&amp;gt; 81 -&amp;gt; 96 -&amp;gt; 85 -&amp;gt; 52. Note que o resultado do caminho pós-ordem em uma árvore binária de pesquisa sempre tem a raíz como último elemento.&lt;/p&gt;

&lt;p&gt;Como isso foi feito? Aplicando o mantra &amp;ldquo;esquerda, direita, nó&amp;rdquo; para cada nó visitado. Inicialmente escolhemos a raíz. Note que só vamos imprimir a raiz depois de visitar todos os nós à sua esquerda e todos os nós à sua direita. Isso é verdade para cada nó visitado. Por isso, caminhamos o máximo à esquerda e depois o máximo à direita. O primeiro elemento a ser impresso é 11. Depois disso 8, 26, 43, 22&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; posOrder() {
    posOrder(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; posOrder(Node &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (node &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) {
        posOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
        posOrder(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);
        System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(node.&lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;);
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;em-largura&#34;&gt;Em Largura&lt;/h3&gt;

&lt;p&gt;O percurso em largura explora inicialmente todos os filhos de um nó primeiro antes de  descer na árvore. Profundidade desce e depois volta. Largura vai descendo &amp;ldquo;varrendo&amp;rdquo; todos os nós no caminho.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Para essa árvore, o resultado do percurso é 52 -&amp;gt; 22 -&amp;gt; 85 -&amp;gt; 8 -&amp;gt; 43 -&amp;gt; 81 -&amp;gt; 96 -&amp;gt; 11 -&amp;gt; 26 -&amp;gt; 69 -&amp;gt; 74.&lt;/p&gt;

&lt;p&gt;Como isso é feito? Para cada nó visitado, exploramos todos os seus filhos antes de seguir adiante. Começamos em 52 e, portanto visitamos 22 e 85. Depois vamos para 22, visitando 8 e 43. Depois 85, visitando 81 e 96 e assim por diante. Veja que esse percurso visita todo o primeiro nível da árvore, depois todos o segundo nível, depois todo o terceiro e assim por diante.&lt;/p&gt;

&lt;p&gt;E como isso é feito? Usamos uma fila para nos auxiliar. O algoritmo é o seguinte.&lt;/p&gt;

&lt;p&gt;Inicia-se a fila com a raiz: &lt;pre&gt;Q = {52}&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Enquanto a fila não estiver vazia, retira-se o primeiro elemento da fila e coloca o seu filho à esquerda e o seu filho à direita na fila. Então retiramos (e imprimimos) 52 da fila e colocamos 22 e 85.&lt;/p&gt;

&lt;pre&gt;Impresso: 52
Q = {&lt;strike&gt;52&lt;/strike&gt;, 22, 85}&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 22 e colocamos 8 e 43.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22
Q = {&lt;strike&gt;52, 22&lt;/strike&gt;, 85, 8, 43}&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 85 e colocamos 81 e 96.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85
Q = {&lt;strike&gt;52, 22, 85&lt;/strike&gt;, 8, 43, 81, 96}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 8 e colocamos apenas 11, pois 8 não possui sub-árvore à esquerda.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8
Q = {&lt;strike&gt;52, 22, 85, 8&lt;/strike&gt;, 43, 81, 96, 11}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Isto é, tiramos 43 e colocamos apenas 26, pois 43 não possui sub-árvore à direita.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43
Q = {&lt;strike&gt;52, 22, 85, 8, 43&lt;/strike&gt;, 81, 96, 11, 26}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 81 e colocamos apenas a sua esquerda (69), pois a direita é nula.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43, 81
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81&lt;/strike&gt;, 96, 11, 26, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 96, mas não colocamos elemento algum porque 96 é folha.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43, 81
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96&lt;/strike&gt;, 11, 26, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 11, mas não colocamos elemento algum porque 11 é folha.&lt;/p&gt;

&lt;pre&gt;Impresso: 52, 22, 85, 8, 43, 81, 96, 11
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11&lt;/strike&gt;, 26, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 26, mas não colocamos elemento algum porque 26 é folha.&lt;/p&gt;

&lt;pre&gt;
Impresso: 52, 22, 85, 8, 43, 81, 96, 11, 26
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11, 26&lt;/strike&gt;, 69}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 69 e colocamos apenas o 74, pois 69 não tem sub-árvore à esquerda.&lt;/p&gt;

&lt;pre&gt;
Impresso: 52, 22, 85, 8, 43, 81, 96, 11, 26, 69
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11, 26, 69&lt;/strike&gt;, 74}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Não, então retira o primeiro elemento dela e coloca sua esquerda e sua direita na fila. Tiramos 74 e não colocamos elemento algum porque 74 é folha.&lt;/p&gt;

&lt;pre&gt;
Impresso: 52, 22, 85, 8, 43, 81, 96, 11, 26, 69, 74
Q = {&lt;strike&gt;52, 22, 85, 8, 43, 81, 96, 11, 26, 69, 74&lt;/strike&gt;}
&lt;/pre&gt;

&lt;p&gt;A fila está vazia? Está! Finalmente :). Veja que a sequência impressa representa o caminho por níveis na árvore da esquerda para a direita.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;percorrendo.png&#34; alt=&#34;percorrendo&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;Percurso em largura: 52, 22, 85, 8, 43, 81, 96, 11, 26, 69, 74.&lt;/p&gt;

&lt;p&gt;Implementação em Java.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; printBFS() {
    Deque&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Node&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; LinkedList&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Node&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;();
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;isEmpty()) {
        queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;root&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;isEmpty&lt;/span&gt;()) {
            Node &lt;span style=&#34;color:#a6e22e&#34;&gt;current&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;removeFirst&lt;/span&gt;();
                
            System.&lt;span style=&#34;color:#a6e22e&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;println&lt;/span&gt;(current);
                
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) 
                queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) 
                queue.&lt;span style=&#34;color:#a6e22e&#34;&gt;addLast&lt;/span&gt;(current.&lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;);   
        }
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Outras-denomina&#34;&gt;Outras denominações utilizadas são: Árvore de Pesquisa Binária, Árvore Binária de Busca (ABB) e Binary Search Tree (BST). Neste material vou usar a sigla BST devido à sua popularidade. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Outras-denomina&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:As-figuras-desse&#34;&gt; As figuras desse material foram feitas no visualgo.net  &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:As-figuras-desse&#34;&gt;&lt;sup&gt;[return]&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
       </item>
       
       <item>
         <title>Heap</title>
         <link>https://joaoarthurbm.github.io/eda/posts/heap/</link>
         <pubDate>Tue, 22 Oct 2019 00:00:00 -0300</pubDate>
         
         <guid>https://joaoarthurbm.github.io/eda/posts/heap/</guid>
         <description>

&lt;hr /&gt;

&lt;p&gt;Nem toda fila segue a política de acesso &lt;em&gt;First In First Out&lt;/em&gt; (FIFO). Na verdade, em vários cenários do dia a dia, as filas que entramos possuem uma política diferente: são filas de prioridade. Por exemplo, mesmo que um adolescente chegue antes de um idoso na fila do banco, é provável que o idoso seja atendido primeiro porque ele tem, por lei (e deveria ter por civilidade também), &lt;strong&gt;prioridade&lt;/strong&gt; no atendimento.&lt;/p&gt;

&lt;p&gt;No contexto de estrutura de dados, precisamos pensar em como manter a estrutura ordenada tendo como critério essa prioridade. Então, vamos primeiro analisar alternativas para implementar filas de prioridade usando estruturas de dados lineares, como &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/linkedlist/&#34;&gt;LinkedList&lt;/a&gt; ou &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/arraylist/&#34;&gt;ArrayList&lt;/a&gt;.
Em primeiro lugar, os objetos passam a ter uma prioridade, que é representada por um atributo inteiro. No nosso exemplo, quanto maior esse número, maior a prioridade. Nesse caso, para implementarmos uma fila de prioridade, temos que tomar uma decisão:  manter a fila ordenada ou não?&lt;/p&gt;

&lt;p&gt;Se decidirmos manter a fila sempre ordenada tendo como critério a prioridade, precisamos utilizar o algoritmo de inserção ordenada, cujo custo é $O(n)$. Contudo, a extração do maior elemento é ${O(1)}$, pois ele sempre está no início da fila.&lt;/p&gt;

&lt;p&gt;Se optarmos por não manter a fila ordenada por prioridade, temos o cenário oposto. A adição passa a ser $O(1)$, mas a remoção do maior passa a ser $O(n)$, pois teremos que pesquisar em toda a fila a maior prioridade.&lt;/p&gt;

&lt;p&gt;Em resumo, temos de um lado adição $O(n)$ e remoção $O(1)$ e do outro lado temos adição $O(1)$ e remoção $O(n)$.&lt;/p&gt;

&lt;p&gt;A estrutura que veremos neste material, &lt;em&gt;Heap&lt;/em&gt;, resolve essa questão permitindo que a adição e extração do máximo sejam ambas realizadas em $O(\log n)$, o que é muito desejável do ponto de vista de eficiência. Além disso, o máximo fica sempre na raiz dessa estrutura, o que permite sua inspeção em $O(1)$.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;definições-e-propriedades&#34;&gt;Definições e Propriedades&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Heaps&lt;/em&gt; são árvores binárias. É importante deixar claro desde já que são árvores binárias, mas não são árvores binárias de pesquisa. Mais especificamente, duas propriedades definem o Heap:&lt;/p&gt;

&lt;pre&gt;
1. O valor de um nó é maior ou igual ao valor de seus filhos;

2. O Heap é uma árvore binária completa ou quase-completa 
da esquerda para a direita.
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Propriedade 1.&lt;/strong&gt; A primeira propriedade é a que difere um Heap de uma árvore binária de pesquisa (BST). Na BST, os valores à esquerda de um nó são menores do que ele e os valores à direita são maiores. No Heap, ambos são menores ou iguais. Heaps que seguem essa propriedade são Heaps Máximos porque o maior valor sempre está na raiz. Há também Heaps Mínimos, onde o nó tem valor sempre menor ou igual ao seus filhos. Neste caso, o menor valor sempre está na raiz. Neste material, vamos utilizar o termo Heap como sinônimo de Heap Máximo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Propriedade 2.&lt;/strong&gt; Se você leu o &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/bst&#34;&gt;material de árvores binárias de pesquisa&lt;/a&gt;, você já sabe o que quer dizer uma árvore completa, certo? Mas,&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;o que quer dizer &lt;i&gt;quase-completa da esquerda para a direita?&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Quer dizer que, se ela não for completa, todos os níveis estão preenchidos, exceto o último, que deve estar preenchido da esquerda para a direita até um certo ponto. Vamos ver exemplos de Heaps e Não-Heaps para esclarecer esse conceito.&lt;/p&gt;

&lt;p&gt;Para exemplos de Heaps, vamos analisar a figura abaixo. Perceba que, além de satisfazerem a propriedade 1, todas as estruturas são completas ou quase-completas da esquerda para a direita e, portanto, são Heaps.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;heaps.png&#34; alt=&#34;heaps&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A primeira estrutura possui 3 níveis:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nível 0: 92&lt;/li&gt;
&lt;li&gt;Nível 1: 92 e 6&lt;/li&gt;
&lt;li&gt;Nível 2: 48 e 70&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O nível 0 e o nível 1 estão completamente preenchidos. O único nível que não está preenchido é o último, mas ele está parcialmente preenchido da esquerda para a direita (46 e 70). Note que não há &amp;ldquo;salto&amp;rdquo; ao percorrer a estrutura em largura. Por isso, essa estrutura é um Heap.&lt;/p&gt;

&lt;p&gt;A segunda estrutura é um Heap porque respeita a primeira propriedade e é uma árvore binária completa.&lt;/p&gt;

&lt;p&gt;A terceira estrutura é um Heap porque respeita a primeira propriedade e é quase-completa da esquerda para a direita. Novamente, todos os níveis exceto o último estão completamente preenchidos e o último nível está parcialmente preenchido da esquerda para a direita:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nível 0: 93&lt;/li&gt;
&lt;li&gt;Nível 1: 74 e 67&lt;/li&gt;
&lt;li&gt;Nível 2: 63, 53, 16 e 41&lt;/li&gt;
&lt;li&gt;Nível 3: 5, 3, 25 e 10 (parcialmente preenchido da esquerda para a direita)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note que, se removêssemos o 25 dessa estrutura, ela não seria mais um Heap, pois o último nível não estaria preenchido da esquerda para a direita. Haveria um salto entre 3 e 10.&lt;/p&gt;

&lt;p&gt;Agora, para fixar bem, vamos ver exemplos de estruturas que não são completas ou quase-completas da esquerda para a direita e, portanto, não são Heaps.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;nao-heaps.png&#34; alt=&#34;nao-heaps&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Em primeiro lugar, nenhuma das estruturas acima é completa. Agora precisamos checar se são quase-completas da esquerda para a direita.&lt;/p&gt;

&lt;p&gt;A primeira estrutura não é quase-completa da esquerda para a direita. Veja:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nível 0: 92. Ok. Está todo preenchido.&lt;/li&gt;
&lt;li&gt;Nível 1: 92. Não está todo preenchido. Por isso não é quase-completa da esquerda para a direita.&lt;/li&gt;
&lt;li&gt;Nível 2: 48 e 70. Está preenchido da esquerda para a direita, mas o nível anterior não. Por isso não está ok.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A segunda estrutura também não é. Veja:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nível 0: 42. Ok. Está todo preenchido.&lt;/li&gt;
&lt;li&gt;Nível 1: 28. Não está preenchido da esquerda para a direita.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Por último, a terceira estrutura também não é quase-completa da esquerda para a direita.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Nível 0: 93. Ok. Está todo preenchido.&lt;/li&gt;
&lt;li&gt;Nível 1: 74 e 67. Ok. Está todo preenchido.&lt;/li&gt;
&lt;li&gt;Nível 2: Não está todo preenchido da esquerda para a direita. Falta um nó à direita de 74. Por isso não é quase-completa da esquerda para a direita.&lt;/li&gt;
&lt;li&gt;Nível 3: Está preenchido da esquerda para a direita, mas o nível anterior não. Por isso não está ok.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;e-por-que-ser-completa-ou-quase-completa-é-importante&#34;&gt;E por que ser completa ou quase-completa é importante?&lt;/h3&gt;

&lt;p&gt;Você há de lembrar que boa parte das operações básicas fundamentais em árvores binárias são $\Theta(h)$, onde $h$ é a altura da árvore. Por isso, é preciso manter a altura próxima da altura mínima possível. Em uma árvore binária a altura mínima é $\Theta(\log n)$, certo?&lt;/p&gt;

&lt;p&gt;Por isso a segunda propriedade de Heap é tão importante. Porque uma árvore completa ou quase-completa possui a altura $\Theta(\log n)$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Por construção, a altura de um Heap é $\Theta(\log n)$, pois é uma estrutura completa ou quase completa da esquerda para a direita. Essa propriedade permite que as operações de inserção e remoção sejam eficientes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Além disso, você pode estar se perguntando: e por que tem que ser quase-completa da esquerda para a direita? Porque isso facilita a implementação dessa estrutura de dados usando um array.&lt;/p&gt;

&lt;h1 id=&#34;implementação&#34;&gt;Implementação&lt;/h1&gt;

&lt;p&gt;Array? Nós havíamos implementado &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/bst&#34;&gt;árvores binárias&lt;/a&gt; utilizando nós, não? Sim, mas quem foi que disse que só tem uma maneira de fazer as coisas? Devido ao fato do Heap ser uma árvore completa ou quase-completa, somos capazes de utilizar um array para representá-lo.&lt;/p&gt;

&lt;h2 id=&#34;como-um-array-pode-representar-um-heap&#34;&gt;Como um array pode representar um Heap?&lt;/h2&gt;

&lt;p&gt;Nós vamos utilizar um array para implementar o Heap. Então, antes precisamos entender como os elementos dispostos em um array podem representar um Heap. Veja o exemplo abaixo:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;heap-exemplo-menor.png&#34; alt=&#34;heap-exemplo-menor&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O array que representa esse Heap é $heap = [48, 24, 45, 14]$. Como? Basta percorrer o Heap em largura e preencher o array. Ou seja, o índice 0 do array sempre será preenchido com a raiz, neste caso o valor 48. Depois, no índice 1, o array é preenchido com o valor 24. O índice 2 recebe o valor 45 e, por último, o índice 3 recebe o valor 14.&lt;/p&gt;

&lt;p&gt;Mais um exemplo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;heap-exemplo.png&#34; alt=&#34;heap-exemplo&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O array que representa esse Heap é $heap = [88, 87, 73, 47, 54, 6, 0, 43]$. Como? Basta percorrer o Heap em largura e preencher o array. Ou seja, o índice 0 do array será preenchido com o valor 88. Depois, no índice 1, o array é preenchido com o valor 87. O índice 2 recebe o valor 73. Os índices 3 e 4 são preenchidos com os valores 47 e 54, respectivamente. Por último, os índices 5, 6 e 7 são preenchidos com os valores 6, 0 e 43, respectivamente.&lt;/p&gt;

&lt;h2 id=&#34;organização-interna-atributos-e-construtor&#34;&gt;Organização Interna: atributos e construtor&lt;/h2&gt;

&lt;p&gt;Em primeiro lugar, já dissemos que a representação do Heap será através de um array. Como temos que definir o tamanho do array de antemão e não sabemos quantos elementos o Heap irá conter, precisamos também ter um atributo (&lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;) que controla o índice do último elemento do array. Vejamos:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; Heap {
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt;[] heap;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; tail;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Heap&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;capacidade&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[capacidade];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; isEmpty() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1;
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Veja que o que define a ocupação do array é o valor do atributo &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;. O método isEmpty, por exemplo, compara esse valor com -1 para determinar se o Heap possui elementos ou não.&lt;/p&gt;

&lt;h2 id=&#34;left-right-e-parent&#34;&gt;left, right e parent&lt;/h2&gt;

&lt;p&gt;Para caminhar em uma árvore precisamos, a partir de um nó, acessar o nó à esquerda, o nó à direita e o nó pai. Na &lt;a class=&#34;external&#34; href=&#34;https://joaoarthurbm.github.io/eda/posts/bst&#34;&gt;implementação de árvores binárias de pesquisa&lt;/a&gt; nós utilizamos as referências &lt;strong&gt;&lt;em&gt;left&lt;/em&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;parent&lt;/em&gt;&lt;/strong&gt;. Contudo, como estamos utilizando um array para armazenar os elementos, precisamos implementar métodos que retornem a esquerda, a direita e o pai de um nó, baseado no seu índice.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;left&lt;/em&gt;&lt;/strong&gt;. A esquerda de um nó no índice &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; sempre segue a fórmula $2*index + 1$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;heap-exemplo.png&#34; alt=&#34;heap-exemplo&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7&lt;/p&gt;

&lt;p&gt;A raiz está no índice 0 do array. Portanto, o nó à sua esquerda está no índice 1, pois $2*0 + 1 = 1$.&lt;/p&gt;

&lt;p&gt;O nó 87 está no índice 1 do array. Portanto, o nó à sua esquerda está no índice 3, pois $2*1 + 1 = 3$.&lt;/p&gt;

&lt;p&gt;O nó 73 está no índice 2 do array. Portanto, o nó à sua esquerda está no índice 5, pois $2*2 + 1 = 3$.&lt;/p&gt;

&lt;p&gt;O nó 47 está no índice 3 do array. Portanto, o nó à sua esquerda está no índice 7, pois $2*3 + 1 = 7$.&lt;/p&gt;

&lt;p&gt;Os nós 54 (índice 4), 6 (índice 5), 0 (índice 6) e 43 (índice 7) não possuem esquerda, pois se aplicarmos a fórmula $2*index+1$ os valores gerados são índices maiores do que &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; e, portanto, não fazem parte do Heap.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;right&lt;/em&gt;&lt;/strong&gt;. A direita de um nó no índice &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; sempre segue a fórmula $2*(index + 1)$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;heap-exemplo.png&#34; alt=&#34;heap-exemplo&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7&lt;/p&gt;

&lt;p&gt;A raiz está no índice 0 do array. Portanto, o nó à sua direita está no índice 2, pois $2*(0 + 1) = 2$.&lt;/p&gt;

&lt;p&gt;O nó 87 está no índice 1 do array. Portanto, o nó à sua direita está no índice 4, pois $2*(1 + 1) = 4$.&lt;/p&gt;

&lt;p&gt;O nó 73 está no índice 2 do array. Portanto, o nó à sua esquerda está no índice 6, pois $2*(2 + 1) = 3$.&lt;/p&gt;

&lt;p&gt;O restante dos nós, índices 3, 4, 5, 6 e 7, não possuem direita, pois se aplicarmos a fórmula $2*(index+1)$ os valores gerados são índices maiores do que &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; e, portanto, não fazem parte do Heap.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;parent&lt;/em&gt;&lt;/strong&gt;. O pai de um nó no índice &lt;strong&gt;&lt;em&gt;index&lt;/em&gt;&lt;/strong&gt; sempre segue a fórmula $int((index-1)/2))$. Basta analisarmos o nosso exemplo para chegar a essa conclusão.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;heap-exemplo.png&#34; alt=&#34;heap-exemplo&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [88, 87, 73, 47, 54, 6, 0, 43]$ e tail = 7&lt;/p&gt;

&lt;p&gt;A raiz está no índice 0 do array. Portanto, não possui nó pai, pois $int((0-1)/2)) = -1$, que é um índice inexistente.&lt;/p&gt;

&lt;p&gt;Os nós 87 e 73 estão nos índices 1 e 2, respectivamente.Portanto, o nó pai está no índice 0, pois $int((1-1)/2)) = 0$ e $int((2-1)/2)) = 0$.&lt;/p&gt;

&lt;p&gt;Os nós 47 e 54 estão nos índices 3 e 4, respectivamente. Portanto, o nó pai está no índice 1, pois $int((3-1)/2)) = 0$ e $int((4-1)/2)) = 1$.&lt;/p&gt;

&lt;p&gt;Os nós 6 e 0 estão nos índices 5 e 6, respectivamente. Portanto, o nó pai está no índice 2, pois $int((5-1)/2)) = 2$ e $int((5-1)/2)) = 2$.&lt;/p&gt;

&lt;p&gt;Por fim, o nó 43 no índice 7 do array. O nó pai está no índice 2, pois $int((7-1)/2)) = 3$.&lt;/p&gt;

&lt;p&gt;Abaixo estão os métodos left, right e parent da classe Heap.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;class&lt;/span&gt; Heap {    
...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; left(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 2 &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1;
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; right(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; 2 &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; 1);
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; parent(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (index&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;1)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;2;
    }
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;inserção&#34;&gt;Inserção&lt;/h2&gt;

&lt;p&gt;Primeiro vamos entender o conceito visualmente, depois passamos para o código, ok?
Suponha que inicialmente nós criamos um array de 10 posições e o Heap armazenado nesse array é o da figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;heap-exemplo.png&#34; alt=&#34;heap-exemplo&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [88, 87, 73, 47, 54, 6, 0, 43, 0, 0]$ e tail = 7&lt;/p&gt;

&lt;p&gt;Note que os elementos que compõe o Heap estão entre os índices 0 e &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt;. Os índices 8 e 9 estão preenchidos com 0 porque é o valor default de Java. Nós tratamos essas posições como livres para serem adicionados novos elementos. Para reforçar: quem define os limites dos elementos presentes no Heap são 0 e &lt;code&gt;tail&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Agora, atenção:&lt;/p&gt;

&lt;pre&gt;
    A adição de um novo elemento sempre é feita na próxima 
    posição livre do array, isto é, tail + 1. Essa estratégia
    garante que o Heap sempre será completo ou quase completo
    da esquerda para a direita.
&lt;/pre&gt;

&lt;p&gt;Então vamos adicionar o valor 100 ao Heap. Como dissemos, a adição é feita em tail + 1. Neste momento, o Heap e o array assumem os seguintes estados.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao1.png&#34; alt=&#34;animacao1&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [88, 87, 73, 47, 54, 6, 0, 43, 100, 0]$ e tail = 8&lt;/p&gt;

&lt;p&gt;Temos um problema aqui, certo? O fato de adicionarmos sempre na próxima posição livre garante que nunca vamos quebrar a propriedade de ser completa ou quase-completa da esquerda para a direita. No entanto, 100 é um valor maior que o valor do nó pai (47). Isso fere a restrição da Propriedade 1, que estabelece que todo nó deve ser maior que seus filhos. A ideia geral para resolver esse problema é comparar 100 com seu pai e, caso ele seja maior, trocar os dois de posição. Isso deve ser feito enquanto 100 for menor do que o pai ou 100 chegar na raiz.&lt;/p&gt;

&lt;p&gt;Vamos ver como isso é feito passo a passo. Na primeira comparação, como 100 é maior que 47, há a troca desses valores, como ilustrado na figura abaixo. Perceba também que o array é modificado.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao2.png&#34; alt=&#34;animacao2&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [88, 87, 73, 100, 54, 6, 0, 43, 47, 0]$ e tail = 8&lt;/p&gt;

&lt;p&gt;O problema ainda persiste, pois 100, quando comparado com o nó pai (87) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao3.png&#34; alt=&#34;animacao3&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [88, 100, 73, 87, 54, 6, 0, 43, 47, 0]$ e tail = 8&lt;/p&gt;

&lt;p&gt;O problema ainda persiste, pois 100, quando comparado com o nó pai (88) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao4.png&#34; alt=&#34;animacao4&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [100, 88, 73, 87, 54, 6, 0, 43, 47, 0]$ e tail = 8&lt;/p&gt;

&lt;p&gt;Feito! Como 100 passou a ser a raiz, a inserção é finalizada.&lt;/p&gt;

&lt;p&gt;Mais um exemplo? Vamos adicionar o elemento 90. Lembrando, a inserção sempre é feita em tail + 1. Então temos o Heap e seu array com o seguinte estado.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao5.png&#34; alt=&#34;animacao5&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [100, 88, 73, 87, 54, 6, 0, 43, 47, 90]$ e tail = 9&lt;/p&gt;

&lt;p&gt;Comparando 90 com o nó pai, temos que 90 &amp;gt; 54 e, portanto, precisamos trocar esse valor. Feito isso, temos o seguinte cenário.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao6.png&#34; alt=&#34;animacao6&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [100, 88, 73, 87, 90, 6, 0, 43, 47, 54]$ e tail = 9&lt;/p&gt;

&lt;p&gt;O problema ainda persiste, pois 90, quando comparado com o nó pai (88) é maior. Novamente, trocamos esses valores, como ilustrado na figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;animacao7.png&#34; alt=&#34;animacao7&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [100, 90, 73, 87, 88, 6, 0, 43, 47, 54]$ e tail = 9&lt;/p&gt;

&lt;p&gt;Feito! Como 90 é menor do que o nó pai (100), a inserção é finalizada.&lt;/p&gt;

&lt;p&gt;Agora que já entendemos como o algoritmo funciona, vamos ao código.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; add(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;n&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (tail &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; (heap.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; 1))
        resize();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
        tail &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; 1;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[tail] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tail;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[parent(i)] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[i]) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[i];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[parent(i)];
            &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[parent(i)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
            i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parent(i);
        }
    }
}
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O primeiro if (&lt;code&gt;tail &amp;gt;= heap.length - 1&lt;/code&gt;) verifica se ainda há espaço no array para adicionar um novo elemento. Se não houver, o método &lt;strong&gt;&lt;em&gt;resize&lt;/em&gt;&lt;/strong&gt; é invocado. Ele apenas cria um array maior e copia os elementos para esse novo array.&lt;/p&gt;

&lt;p&gt;Caso haja espaço (&lt;code&gt;else&lt;/code&gt;), incrementamos tail (&lt;code&gt;tail += 1&lt;/code&gt;) e adicionamos o novo elemento no array (&lt;code&gt;this.heap[tail] = n&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Agora vamos à rotina de comparar com o valor do nó pai enquanto for maior ou não atingir a raiz. Isso é feito no bloco do while. Caso essas duas condições forem satisfeitas, troca-se os valores do nó e do pai e atualiza o índice do elemento a ser verificado na próxima iteração (&lt;code&gt;i = parent(i)&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;eficiência-do-método-de-inserção&#34;&gt;Eficiência do método de inserção&lt;/h3&gt;

&lt;p&gt;No pior caso, o elemento adicionado é o maior elemento do Heap e, por isso, temos que subir até a raiz. Nesse pior caso, o caminho percorrido é igual ao tamanho da altura, que sempre é $O(\log n)$ porque o Heap é completo ou quase-completo da esquerda para a direita.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A inserção de um elemento no Heap é $O(\log n)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;remoção-e-heapify&#34;&gt;Remoção e Heapify&lt;/h2&gt;

&lt;p&gt;A remoção em um Heap não é parametrizada. O elemento removido sempre é o maior, ou seja, sempre a raiz.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A remoção em um heap é sempre feita na raiz.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Para manter a propriedade de ser completo ou quase-completo da esquerda para a direita, trocamos o valor da raiz com a última folha e removemos essa última folha. Note que, por ser um array, não removemos de fato a posição, apenas atualizamos tail (&lt;code&gt;tail = tail - 1&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Vamos visualizar esse processo para o Heap abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;remocao1.png&#34; alt=&#34;remocao1&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [100, 90, 73, 87, 88, 6, 0, 43, 47, 54]$ e tail = 9&lt;/p&gt;

&lt;p&gt;O primeiro passo então, é trocar a raíz (&lt;code&gt;this.heap[0]&lt;/code&gt;) pela última folha (&lt;code&gt;this.heap[tail]&lt;/code&gt;). No nosso exemplo, isso significa que 54 passa a ser a raiz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;remocao2.png&#34; alt=&#34;remocao2&#34; /&gt;&lt;/p&gt;

&lt;p align=&#34;center&#34;&gt;$heap = [54, 90, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 9&lt;/p&gt;

&lt;p&gt;Agora decrementamos o valor de tail &lt;strong&gt;&lt;em&gt;tail&lt;/em&gt;&lt;/strong&gt; (&lt;code&gt;tail -= 1&lt;/code&gt;). O Heap fica nesse estado:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;remocao3.png&#34; alt=&#34;remocao3&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;$heap = [54, 90, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 8&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Temos um problema, certo? 54 é menor que o valor à sua esquerda e que o valor à sua direita. O que vamos fazer a partir de agora é resolver esse problema. E isso tem nome: &lt;strong&gt;heapify&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A ideia geral é comparar 54 com o filho à esquerda e o filho à direita. O maior dos três assume a posição de 54. Se o maior dos 3 for 54, o algoritmo não precisa seguir adiante. Vamos lá.&lt;/p&gt;

&lt;p&gt;Comparando 54, 90 e 73, o maior valor é 90. Portanto, trocamos 90 com 54.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;remocao4.png&#34; alt=&#34;remocao4&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;$heap = [90, 54, 73, 87, 88, 6, 0, 43, 47, 100]$ e tail = 8&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Novamente, comparamos 54 com o filho à esquerda e o filho à direita. O maior dos três assume a posição de 54. Ou seja, trocamos 54 por 88.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;remocao5.png&#34; alt=&#34;remocao5&#34; /&gt;
&lt;p align=&#34;center&#34;&gt;$heap = [90, 88, 73, 87, 54, 6, 0, 43, 47, 100]$ e tail = 8&lt;/p&gt;&lt;/p&gt;

&lt;p&gt;Feito! 54 não possui mais filhos e, portanto, o algoritmo para.&lt;/p&gt;

&lt;p&gt;Agora que já entendemos como o algoritmo funciona, vamos às particularidades do código aos poucos. Primeiro, a ideia geral do método &lt;strong&gt;&lt;em&gt;remove()&lt;/em&gt;&lt;/strong&gt;, que outros autores também chamam de &lt;strong&gt;&lt;em&gt;extractMax()&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; remove() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isEmpty()) &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; RuntimeException(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Empty&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;element&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[0];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[0] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[tail];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; 1;

        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heapify&lt;/span&gt;(0);
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; element;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Esse código implementa o que discutimos. Primeiro, armazena a raiz em uma variável temporária para poder retornar (&lt;code&gt;element = this.heap[0]&lt;/code&gt;). Depois, coloca na raiz o valor presente na última folha (&lt;code&gt;this.heap[0] = this.heap[tail]&lt;/code&gt;) e diminui o tamanho do heap (&lt;code&gt;this.tail -= 1&lt;/code&gt;) para poder iniciar o &lt;strong&gt;&lt;em&gt;heapify&lt;/em&gt;&lt;/strong&gt; a partir dela (&lt;code&gt;heapify(0)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;E o &lt;strong&gt;&lt;em&gt;heapify&lt;/em&gt;&lt;/strong&gt;?&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; heapify(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isLeaf(index) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;isValidIndex(index)) 
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
        
        &lt;span style=&#34;color:#75715e&#34;&gt;// compares index, left and right to find max
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index_max&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_index(index, left(index), right(index));
        
        &lt;span style=&#34;color:#75715e&#34;&gt;// if current index is not greater than its children, 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// swap and keep heapifying.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index_max &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; index) {
                swap(index, index_max);
                heapify(index_max);
        }
    }  
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;O primeiro passo é verificar as condições de parada. Isso significa checar se o índice passado como parâmetro é uma folha ou está fora dos limites do Heap. Nesses dois casos não há a necessidade de efetuar o heapify.&lt;/p&gt;

&lt;p&gt;Se houver a necessidade, comparamos index com left e right para determinar qual é o máximo entre eles. Isso é feito pelo método &lt;strong&gt;&lt;em&gt;max_index&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Se o máximo entre eles for o próprio index, o algoritmo para. Caso contrário, trocamos index pelo máximo (&lt;code&gt;swap(index, index_max)&lt;/code&gt;) e continuamos a efetuar o heapify a partir do índice que armazenava o máximo (&lt;code&gt;heapify(index_max)&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Abaixo estão as implementações dos métodos auxiliares &lt;strong&gt;&lt;em&gt;max_index, isValidIndex, isLeaf&lt;/em&gt;&lt;/strong&gt; e &lt;strong&gt;&lt;em&gt;swap&lt;/em&gt;&lt;/strong&gt;. Como dito anteriormente, o método max_index compara os valores em index, left e right para identificar o maior deles. Você vai notar que há algumas verificações relacionadas à validade dos índices, uma vez que o índice deve estar dentro do intervalo $[0, tail]$.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;int&lt;/span&gt; max_index(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;left&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;right&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[index] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[left]) {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isValidIndex(right)) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[index] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[right])
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right;
            }
           
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; index;
        
        } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (isValidIndex(right)) {
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[left] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[right])
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; right;
            } 
            
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left;
        }
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; isValidIndex(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; tail;
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;boolean&lt;/span&gt; isLeaf(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; parent(tail) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; tail;
    } 
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; swap(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aux&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[i];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[j];
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; aux;
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;eficiência-do-método-de-inserção-1&#34;&gt;Eficiência do método de inserção&lt;/h3&gt;

&lt;p&gt;No pior caso o heapify é executado até o nível das folhas. Nesse pior caso, o caminho percorrido é igual ao tamanho da altura, que sempre é $O(\log n)$ porque o Heap é completo ou quase-completo da esquerda para a direita.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A remoção de um elemento no Heap é $O(\log n)$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;build-heap&#34;&gt;Build Heap&lt;/h2&gt;

&lt;p&gt;Nem todo array representa um Heap, certo? Por exemplo, o array $a = [40, 87, 2, 90, 1, 100, 30, 20]$ não representa um Heap porque nem todo nó é maior do que os nós à esquerda e à direita, como ilustrado na figura abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;build-heap1.png&#34; alt=&#34;build-heap1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;O nosso desafio agora é transformar essa estrutura em um Heap. A ideia é aplicar sucessivas vezes o algoritmo &lt;strong&gt;&lt;em&gt;heapify&lt;/em&gt;&lt;/strong&gt;, discutido na seção anterior.&lt;/p&gt;

&lt;p&gt;Nós começamos pelo pai da última folha. Por que? Porque a aplicação do heapify nas folhas é inútil, já que uma folha já respeita as propriedade de Heap.&lt;/p&gt;

&lt;p&gt;Então, para o exemplo acima, vamos aplicar primeiro heapify no índice 3, que armazena o valor 90. Depois, vamos aplicar em todos os índices menores que 3 até a raiz, ou seja, heapify(2), heapify(1) e heapify(0). Ao final desse processo o array representará um Heap.&lt;/p&gt;

&lt;p&gt;Vamos acompanhar passo a passo esse algoritmo. A primeira execução do heapify é no índice 3, que armazena 90. Como 90 é maior que o seu único filho, nada é feito. Depois aplicamos o heapify no índice 2, que armazena o valor 2. O heapify então compara 2, 100 e 30. Como 100 é maior, há a troca de valores entre 100 e 2. O resultado parcial até agora é o seguinte.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;build-heap2.png&#34; alt=&#34;build-heap2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Agora falta aplicar no índice 1 e 0. Aplicando heapify no índice 1, o algoritmo compara 87 com 90 e 1. Como 90 é maior, há a troca de valores entre 90 e 87. Depois disso, 87 é comparado com 2. Como é maior, o algoritmo para. Até aqui, temos o seguinte cenário.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;build-heap3.png&#34; alt=&#34;build-heap3&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Por fim, falta apenas a última aplicação de heapify. Isso é feito no índice 0, ou seja, na raiz.O resultado final é ilustrado abaixo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;build-heap4.png&#34; alt=&#34;build-heap4&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Em resumo, para construir um Heap a partir de um array qualquer basta aplicar &lt;strong&gt;&lt;em&gt;heapify&lt;/em&gt;&lt;/strong&gt; partindo do índice do pai da última folha até a raiz. O código abaixo implementa essa rotina.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;...
    &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Heap&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;heap&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; heap;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;buildHeap&lt;/span&gt;();
    }
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;void&lt;/span&gt; buildHeap() {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parent(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tail&lt;/span&gt;); i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; 0; i&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;)
            heapify(i); 
    }
...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;hr /&gt;

&lt;h1 id=&#34;resumo&#34;&gt;Resumo&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Heap é uma árvore binária.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Todos os nós presentes no Heap são maiores que os seus nós à esquerda e à direita. Isso quer dizer que o maior valor sempre está na raiz.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Heap é uma árvore completa ou quase-completa da esquerda para a direita. Esta propriedade garante que a altura da árvore é sempre a mínima possível, ou seja, $O(\log n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Esta última propriedade garante inserção e remoção em $O(\log n)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Heap é uma excelente alternativa para implementação de filas de prioridade.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Por ser completo ou quase-completo da esquerda para a direita, podemos implementar Heaps em arrays, ao invés de nós ligados.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A array que representa um Heap é o resultado do seu percurso em largura. Ou seja, a raiz sempre está no índice 0. Nos índices 1 e 2 estão os elementos do nível 1. Nos índices 3, 4, 5 e 6 estão os elementos do nível 2 e assim por diante.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Os métodos left, right e parent são implementados de acordo com os índices dos elementos no array. A esquerda de um nó no índice *&lt;strong&gt;i&lt;/strong&gt; é dada por $2*i+1$. A direita de um nó no índice *&lt;strong&gt;i&lt;/strong&gt; é dada por $2*(i+1)$. O pai de um nó no índice &lt;strong&gt;&lt;em&gt;i&lt;/em&gt;&lt;/strong&gt; é dados por $int((index - 1) / 2)$.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A adição de um elemento é sempre feita na próxima posição livre do array. Depois de adicionado, deve-se comparar o elemento com o pai. Se o seu valor foi maior, troca-se os elementos. Esse processo é feito enquanto o valor for maior ou não chegar na raiz.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;O elemento removido sempre é o maior, isto é, a raiz. Antes disso, colocamos o valor da última folha na raiz e executamos o heapify.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Heapify é uma rotina que compara um nó, a sua esquerda e a sua direita. O maior dos três deve ser a raiz dessa sub-arvore. Caso o maior dos três seja o próprio nó, o algoritmo para. Caso contrário, segue a comparação árvore abaixo.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Para construir um Heap a partir de um array qualquer, basta executar o heapify seguidas vezes. Partindo o pai da última folha até a raiz. Esse método se chama &lt;strong&gt;&lt;em&gt;Build Heap&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;notas&#34;&gt;Notas&lt;/h1&gt;

&lt;p&gt;Utilizar uma ferramenta de visualização facilita muito o aprendizado das estruturas que estudamos. Para fazer as figuras deste material eu utilizei &lt;a class=&#34;external&#34; href=&#34;http://btv.melezinek.cz/binary-heap.html&#34;&gt;esta ferramenta.&lt;/a&gt; Também recomendo o &lt;a class=&#34;external&#34; href=&#34;visualgo.net&#34;&gt;VisualAlgo&lt;/a&gt;.&lt;/p&gt;
</description>
       </item>
       
     </channel>
   </rss>
